% !TEX encoding = System

%%\documentclass[thesismargins, thesislinespacing, twoside, draft, upjsfrontpage]{rnthesis}
\documentclass{rnthesis}
\usepackage[slovak]{babel}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{rnt-pic}
\usepackage{rnt-thm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}
\usepackage{hyphenat}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{array}
\usepackage{nameref}
\usepackage{array}
\usepackage{makecell}
\usepackage{arydshln}
\usepackage{tabularx}
\usepackage{bm}
\usepackage{MnSymbol}
\usepackage{scrextend}
\usepackage{booktabs}
\usepackage{xfrac}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%\usepackage{fontspec}
% cierne linky bez ohranicenia
\usepackage[bookmarksnumbered,colorlinks=true, allcolors=black]{hyperref}
% linky s ohranicenim
%\usepackage[bookmarksnumbered,colorlinks=false, allcolors=black]{hyperref}

\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage{tikz}


\makeatletter
\renewcommand{\ALG@name}{Algoritmus}
\renewcommand{\listalgorithmname}{Zoznam algoritmov}

\renewcommand\algorithmicwhile{\textbf{pokia¾}}
\renewcommand\algorithmicdo{\textbf{}}
\renewcommand\algorithmicend{\textbf{koiec}}
\renewcommand\algorithmicif{\textbf{ak}}
\renewcommand\algorithmicthen{\textbf{potom}}
\renewcommand\algorithmicelse{\textbf{inak}}
\renewcommand\algorithmicfor{\textbf{pre}}
\renewcommand\algorithmicprocedure{\textbf{procedúra}}

\makeatother

\newcommand\diag[4]{%
	\multicolumn{1}{p{#2}|}{\hskip-\tabcolsep
		$\vcenter{\begin{tikzpicture}[baseline=0,anchor=south west,inner sep=#1]
			\path[use as bounding box] (0,0) rectangle (#2+2\tabcolsep,\baselineskip);
			\node[minimum width={#2+2\tabcolsep-\pgflinewidth},
			minimum  height=\baselineskip+\extrarowheight-\pgflinewidth] (box) {};
			\draw[line cap=round] (box.north west) -- (box.south east);
			\node[anchor=south west] at (box.south west) {#3};
			\node[anchor=north east] at (box.north east) {#4};
			\end{tikzpicture}}$\hskip-\tabcolsep}}


\hyphenation{funk-cií}

\RequirePackage{ifpdf}

\ifpdf
\RequirePackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{eps}{*}{}
\else
\RequirePackage[xdvi]{graphicx}
\fi

\lstset{language=[Sharp]C,
showspaces=false,
showtabs=false,
breaklines=true,
%basicstyle=\tiny,
basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
numbersep=5pt,
tabsize=2,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{commentsColor},
keywordstyle=\color{keywordsColor}\bfseries,
stringstyle=\color{stringsColor},
%basicstyle=\ttfamily
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morekeywords={abstract, event, new, struct,
as, explicit, null, switch,
base, extern, object, this,
bool, false, operator, throw,
break, finally, out, true,
byte, fixed, override, try,
case, float, params, typeof,
catch, for, private, uint,
char, foreach, protected, ulong,
checked, goto, public, unchecked,
class, if, readonly, unsafe,
const, implicit, ref, ushort,
continue, in, return, using,
decimal, int, sbyte, virtual,
default, interface, sealed, volatile,
delegate, internal, short, void,
do, is, sizeof, while,
double, lock, stackalloc,
else, long, static,
enum, namespace, string, partial, get, set, var},
}

\lstset{language=C++,
	showspaces=false,
	showtabs=false,
	breaklines=true,
	%basicstyle=\tiny,
	basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
	numbersep=5pt,
	tabsize=2,
	showstringspaces=false,
	breakatwhitespace=true,
	escapeinside={(*@}{@*)},
	commentstyle=\color{commentsColor},
	keywordstyle=\color{keywordsColor}\bfseries,
	stringstyle=\color{stringsColor},
	%basicstyle=\ttfamily
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morekeywords=
	{
		alignas,alignof,and,and\_eq,asm,auto,
		bitand,bitor,bool,break,
		case,catch,char,char16\_t,char32\_t,
		class,compl,concept,const,constexpr,
		const\_cast,continue,
		decltype,default,delete,do,double,d^ynamyc\_cast,
		else,enum,explicit,export,extern,
		false,float,for,friend,
		goto,
		if,inline,int,
		long,
		mutable,
		namespace,new,noexcept,not,not\_eq,nullptr,
		operator,or,or\_eq,
		private,protected,public,
		register,reinterpret\_cast,requires,return,
		short,signed,sizeof,static,static\_assert,
		static\_cast,struct,switch,
		template,this,thread\_local,throw,true,try,
		typedef,typeid,typename,
		union,unsigned,
		virtual,void,volatile,
		wchar\_t,while,
		xor,xor\_eq
	},
}

%Setup pseudocode

%\usepackage{xcolor}

%\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lr, rulecolor=\color{blue!80!black}}
%----------------------------------------------------------------------------------------
\newcommand{\cpp}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\newcommand{\real}{$\mathbb{R}$}
\newcommand{\uinteger}{$\mathbb{N} \cup \{0\}$} 
\newcommand{\nat}{$\mathbb{N} \cup \{0\}$} 
\newcommand{\integer}{$\mathbb{Z}$}
\newcommand{\mcomma}{\mbox{,}}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}
\newcommand{\FEL}{\frac{1}{2}}
\newcommand*{\mathcolor}{}

%\newcolumntype{?}{!{\vrule width 1pt}}
\newcolumntype{?}[1]{!{\vrule width #1pt}}
\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\def\der#1#2{\frac{d #1}{d #2}}
\def\pd#1#2{\frac{\partial #1}{\partial #2}}
\def\pdd#1#2#3{\frac{\partial^2 #1}{\partial #2\partial#3}}

\def\TP#1{\mathit{#1}}
\def\FN#1{\text{#1}}
\def\uv#1{„{#1}“}
\definecolor{basis1}{rgb}{0.64,0.29,0.64}
\definecolor{basis2}{rgb}{0,0.64,0.91}
\definecolor{basis3}{rgb}{0.13,0.69,0.3}
\definecolor{basis4}{rgb}{0.93,0.11,0.14}
\definecolor{basis1a}{rgb}{0.90,0.6,0.90}
\definecolor{basis2a}{rgb}{0.2,0.80,1}
\definecolor{basis3a}{rgb}{0.3,0.9,0.5}
\definecolor{basis4a}{rgb}{1,0.7,0.7}


%\definecolor{dkgreen}{rgb}{0,0.6,0}
%\definecolor{gray}{rgb}{0.5,0.5,0.5}
%\definecolor{mauve}{rgb}{0.64,0.08,0.08}

\definecolor{keywordsColor}{rgb}{0.25,0,0.5}
\definecolor{commentsColor}{rgb}{0,0.5,0}
\definecolor{stringsColor}{rgb}{0.64,0.375,0.25}
%----------------------------------------------------------------------------------------
\catcode`@=11
\def\xmatrix#1#2{\null\,\vcenter{\normalbaselines\m@th
    \ialign{\hfil$##$\hfil&&\hskip#1\hfil$##$\hfil\crcr
      \mathstrut\crcr\noalign{\kern-\baselineskip}
      #2\crcr\mathstrut\crcr\noalign{\kern-\baselineskip}}}\,}
\catcode`@=12

\title{Zrıchlenie vıpoètu splajn povrchov}
%\subtitle{Algoritmizácia, paralelizácia a implementácia splajn modelov}
\author{Bc. Viliam Kaèala}
\typprace{Diplomová}
\rok{2016}
\miesto{Košice}
\podakovanie{
 Rád by som poïakoval vedúcemu závereènej
 práce doc. RNDr. Csabovi Törökovi, CSc.
 za cenné pripomienky, odborné vedenie a obetavos poèas
 tvorby práce. Taktie by som sa rád poïakoval 
 RNDr. Lukášovi Miòovi za cenné rady a
 pomoc poèas tvorby aplikaènej èasti tejto práce.
} 
\veduci{doc. RNDr. Csaba Török, CSc.}
\konzultant{RNDr. Lukáš Miòo}
\pracovisko{Ústav informatiky}

\abstract{
	Splines are important part of computer graphics.
	It is a mathematical model of the surface, which is for the "best connection" of any finite set of points.
	The term "best connection" in this case means smooth, easily calculable mathematical surface with minimal curvature.
	Use of splines in graphics varies from large variety of CAD applications, statistics or in data analysing.
	Splines exist in many forms, whether in the form of curves in the plane, a variety of three-dimensional bodies, etc. ..
	This work aims to desig, analyze and implement new algorithm for counting and generating splines bicubic clamped interpolation in three-dimensional space.
}

\abstrakt{
	Splajny sú dôleitá súèas poèítaèovej grafiky.
	Jedná sa o matematickı model plochy, ktorá slúi na èo „najlepšie spojenie“ koneènej mnoiny bodov. 
	Termín „najlepšie spojenie“ v našom prípade znamená hladká, matematicky ¾ahko vyjadrite¾ná plocha s èo najmenším zakrivením.
	Vyuitie splajnov v grafike je ve¾mi široké od rôznych CAD aplikácií, v štatistike, alebo v analıze dát.
	Splajny existujú v mnohıch formách, èi u vo forme krivky v rovine, rôznych trojrozmernıch telies, atï..
	Táto práca si dáva za cie¾ navrhnú, analyzova a implementova novı algoritmus pre bikubickú interpoláciu v trojrozmernom priestore.
}

\bibliographystyle{alpha}

\begin{document}

\maketitle
\newpage
\tableofcontents
%\listofalgorithms
\newpage
%==================================================================================================================================================================================
\chapter*{Úvod}

Témou mojej diplomovej práce sú rovinné krivkové splajny a priestorové splajn povrchy, prièom naším cie¾om je preskúma nové poznatky o splajnoch, na ktorıch istı èas pracuje vedúci tejto práce doc. RNDr. Csaba Török, CSc.

Vısledok tejto práce je návrh novej metódy vıpoètu derivácií splajnu v jeho uzloch, jej porovnanie s de Boorovym postupom z ktorého vychádzame, vysvetlenie zrıchlenia a implementácia aplikácií na vizuálne a vıkonnostne porovnávanie oboch metód.

Prínos zrıchlenia vıpoètu splajnov spoèíva v lepších monostiach modelovania ¾ubovo¾nıch trojrozmernıch útvarov ako po èastiach polynomickıch funkcií. 
Akéko¾vek zrıchlenie toti znamená monos v reálnom èase modelova zloitejšie objekty. 
Technológia v ktorej tieto poznatky implementujeme je Microsoft Silverlight. 
Jedná sa o ve¾mi schopnı nástroj na tvorbu webovıch aplikácii s plnou podporou hardvérovej akcelerácie uívate¾ského prostredia a monosou tvorby rıchlej trojrozmernej grafiky. 
Vıhodou tohto frameworku je, kede beí na platforme Microsoft .NET, monos jednoduchej portácie na desktopovú prípadne mobilnú aplikáciu. 
Na vıkonnostné porovnanie nášho algoritmu s existujúcim však implementujeme samostatnú aplikáciu nad \cpp.

Štruktúra práce je nasledovná.
\begin{itemize}
\item{\textbf{De Boorov algoritmus a návrh zrıchlenia}}
\begin{itemize}
	\item{\textbf{Polynómy}}\newline
	Základné pojmy o polynómoch.
	\item{\textbf{Splajny}}\newline
	Definícia krivkovıch a povrchovıch splajn.
	\item{\textbf{LU dekompozícia}}\newline
	Spôsob poèítania trojdiagonálnych sústav.
	\item{\textbf{De Boorova interpolácia}}\newline
	V tejto èasti si vysvetlíme splajn interpoláciu pod¾a Carla de Boora. 	
	\item{\textbf{Poèítanie derivácií redukovanou sústavou}}\newline
	Ukáka modifikovaného postupu pre kubické splajny a jeho rozšírenie pre bikubické splajny.	
	\item{\textbf{Konštrukcia splajnu}}\newline
	Zostrojenie splajnu ako zloenej funkcie segmentov.
\end{itemize}
\item{\textbf{Zrıchlenie}}\newline
Oèakávané zrıchlenie vıpoètov novım algoritmom.
\begin{itemize}
	\item{\textbf{Procesorová architektúra}}\newline
	Tu si objasníme vplyv modernıch inštrukènıch sád na zrıchlenie redukovaného algoritmu.
	\item{\textbf{Poèty operácií}}\newline
	Spoèítanie èasovej zloitosti  vysvetlenie vplyvu základnıch aritmetickıch a pamäovıch operácií. 
\end{itemize}
\item{\textbf{Implementácia a uívate¾ská príruèka}}\newline
Podrobnosti implementácie v MS Silverlight a \cpp. 
Struènı návod na pouitie programov.
\item{\textbf{Záver}}\newline
\end{itemize}

Formálne tézy diplomovej práce sú:

\begin{itemize}
	\item
	Analıza modelov interpolaènıch splajnov.
	\item
	Redukovanı algoritmus vıpoètu koeficientov splajn povrchov.
	\item
	Testovanie faktorov vplıvajúcich na rıchlos vıpoètu splajn koeficientov
	\begin{itemize}
		\item
		Klasickı a Hermitov splajn
		\item
		De Boorov a redukovanı algoritmus
		\item
		Vplyv latencie a priepustnosti procesorovıch inštrukcií a vyrovnávacích pamätí.  
	\end{itemize}
\end{itemize}

\chapter{De Boorov algoritmus a návrh zrıchlenia}

V tejto kapitole si postupne zadefinujeme pojem polynómu a tento postupne rozšírime na pojem splajnu. 
Následne si popíšeme dve metódy vıpoètu derivácií splajnu a konštrukciu celej splajnovej krivky alebo plochy.

\section{Polynómy}

Pre úplnos skôr ne si povieme o splajnoch, predstavíme si pojem polynomickej funkcie ktorı je neoddelite¾nou súèasou pri definícii splajnu. 

\begin{df}
	Nech $n$ je z \uinteger a pre kadé $i$ z $\{0, \dots, n\}$ je $a_i$ z \real, prièom $a_n \ne 0$. Funkciu $p: \mathbb{R} \to \mathbb{R}$ tvaru
	$$p(x)=\sum_{i = 0}^{n}a_i x^i$$
	nazveme \pojem{polynomická funkcia jednej premennej stupòa $n$}.
\end{df}

\oznac{
	Polynomické funkcie jednej premennej budeme skrátene nazıva \pojem{polynomické funkcie}.
	Špeciálne polynomické funkcie stupòa $3$ nazveme \pojem{kubické funkcie}.
}

V práci však budeme pracova najmä s funkciami dvoch premennıch. Analogicky si pre dve premenné zadefinujme aj polynomické funkcie.

\begin{df}
	Nech $n$ a $m$ sú z \uinteger a pre kadé $i$ z $\{0, \dots, n\}$ a $j$ z $\{0, \dots, m\}$ je $a_{ij}$ z \real, prièom $a_{nm} \ne 0$. Funkciu $p: \mathbb{R} \times \mathbb{R} \to \mathbb{R}$ tvaru
	$$p(x,y)=\sum_{0}^{n}\sum_{0}^{m}a_{ij} x^i y^j$$
	nazveme \pojem{polynomická funkcia dvoch premennıch stupòov $n$ a $m$}
\end{df}

\oznac{
	Polynomické funkcie dvoch premennıch budeme skrátene nazıva \pojem{bipolynomické funkcie}.
	Bipolynomické funkcie stupòov $3$ a $3$ nazveme \pojem{bikubické funkcie}.
}

\section{Splajny}

V našej práci pracujeme s hermitovskımi splajnami, ktoré sú štandardne triedy $C^1$, teda splajnami, ktorıch prvé derivácie v uzloch sa rovnajú. 
Pre naše potreby budeme uvaova iba hermitovské splajny triedy $C^2$, teda tie pri ktorıch v uzloch máme zaruèenú rovnos aj derivácií druhého rádu. 
Všeobecne sa splajny triedy $C^2$ nazıvajú \pojem{naturálne splajny}\cite{her_nat}. 

Keïe naším cie¾om je zrıchlenı algoritmus poèítania povrchovıch splajnov, ktorı vznikol zovšeobecnením algoritmu pre krivkové splajny tak si zavedieme pojem splajnu pre krivky aj plochy.
Iste by bolo mono elegantnejšie zadefinova splajn všeobecne, ale rozdelenie definície špeciálne pre krivkové splajny v rovine a povrchové v priestore bude èitate¾nejšie.  
 
\obrazok{mexHatWKnots.png}{0.7}{Funkcia $sin(\sqrt{x^2+y^2})$ aproximovaná bikubickım splajnom.}
Formálnejšie si popíšme základné pojmy s ktorımi budem v tomto èlánku pracova. 

\oznac{
	Postupnos $(a_0, a_1, \dots)$ nazveme \pojem{rovnomere rastúcou} ak pre ¾ubovo¾né $i$ z $\{0, 1, \dots\}$ platí $a_{i+1} > a_i$ a 
	pre ¾ubovo¾né $i$,$j$ z $\{0, 1, \dots\}$ platí $a_{j+1} - a_j = a_{i+1} - a_i$.
}

Formálna definícia krivkového splajnu v rovine je nasledovná.

\begin{df}\label{df:curve_spline}
	Nech $I \ge 0$ je prirodzené èíslo, $(u_0, \dots,u_{I-1})$ je rovnomerne rastúca postupnost.
	Nech pre kadé $i$ z $\{0, 1, \dots I-2\}$ funkcie $S_{i}$ sú polynomické funkcie, ktoré spåòajú
	\begin{itemize}
		\item
		$S_{i}(u_{i+1}) = S_{i+1}(u_{i+1})$,
		\item
		$\der{S_{i}}{x}(u_{i+1}) = \der{S_{i+1}}{x}(u_{i+1})$ 
	\end{itemize}
	Funkciu $S$ z intervalu $[u_{0}, u_{I-1}]$ do $\mathbb{R}$ pre ktorú platí:
	\begin{equation}
	S(x) = \begin{cases}
	S_{0}(x,y) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	S_{1}(x,y) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	\vdots\\
	S_{I-1}(x,y) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	\end{cases}
	\end{equation}
	nazveme \pojem{krivkovı splajn}.
\end{df}

\oznac{
	Pri oznaèeniach z predchádzajúcej definície oznaème:
	\begin{itemize}
		\item
		Funkcie $S_{i}$ nazveme \pojem{segmenty}.
		\item
		Hodnoty $u_i$ nazveme \pojem{uzly}.
		\item
		Uzly $u_0$ a $u_{I-1}$ nazveme \pojem{krajné uzly}.
		\item
		$z_{i} = S(u_i)$ nazveme \pojem{funkèné hodnoty splajnu v uzloch}.
		\item
		$d^x_{i} = \der{S(u_i)}{x}$ nazveme \pojem{derivácie v uzloch}.
		$h = u_i - u_{i-1}$ pre ¾ubovo¾né $i \in  \{1, \dots, I-1\}$.
	\end{itemize}
}

Definíciu krivkového splajnu následne rozšírime na povrchovı splajn.

\begin{df}\label{df:surface_spline}
Nech $I \ge 0$ a  $J \ge 0$ sú prirodzené èísla, $(u_0, \dots,u_{I-1})$ a $(v_0, \dots,v_{J-1})$ sú rovnomerne rastúce postupnosti.
Nech pre kadé $i$ z $\{0, 1, \dots I-2\}$ a $j$ z $\{0, 1, \dots J-2\}$ funkcie $S_{i,j}$ sú bipolynomické funkcie, ktoré spåòajú
\begin{itemize}
\item
$S_{i,j}(u_{i+1}, y) = S_{i+1,j}(u_{i+1}, y)$,
\item 
$S_{i,j+1}(x, v_{j+1}) = S_{i,j+1}(x, v_{j+1})$,
\item
$\pd{S_{i,j}}{x}(u_{i+1}, y) = \pd{S_{i+1,j}}{x}(u_{i+1}, y)$ 
\item
$\pd{S_{i,j+1}}{y}(x, v_{j+1}) =\pd{S_{i,j}}{y}(x, v_{j+1})$,
%\item
%$\pdd{S_{i,j+1}}{x}{y}(x, v_{j+1}) =\pd{S_{i,j}}{y}(x, v_{j+1})$.
%$\pdd{S(u_i, v_i)}{x}{y} = \pdd{S(u_{i+1}, v_j)}{x}{y} = \pdd{S(u_i, v_{j+1})}{x}{y} = \pdd{S(u_{i+1}, v_{j+1})}{x}{y}$.
\end{itemize}
Funkciu $S$ z intervalu $[u_{0}, u_{I-1}] \times [v_{0}, v_{J-1}]$ do $\mathbb{R}$ pre ktorú platí:
	\begin{equation}
	S(x,y) = \begin{cases}
	S_{0,0}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{0}, v_{1}] \text{,}\\
	S_{0,1}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{1}, v_{2}] \text{,}\\
	\vdots\\
	S_{0,J-1}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{J-2}, v_{J-1}] \text{,}\\
	S_{1,0}(x,y) & \text{pre } (x, y) \in [u_{1}, u_{2}] \times [v_{0}, v_{1}] \text{,}\\
	\vdots\\
	S_{1,J-1}(x,y) & \text{pre } (x, y) \in [u_{1}, u_{2}] \times [v_{J21}, v_{J-1}] \text{,}\\
	\vdots\\
	S_{I-1,0}(x,y) & \text{pre } (x, y) \in [u_{I-2}, u_{I-1}] \times [v_{0}, v_{1}] \text{,}\\
	\vdots\\
	S_{I-1,J-1}(x,y) & \text{pre } (x, y) \in [u_{I-2}, u_{I-1}] \times [v_{J-2}, v_{J-1}] \text{,}
	\end{cases}
	\end{equation}
	nazveme \pojem{splajn}.
\end{df}

\oznac{
	Pre úplnos analogicky ako pri krivkách oznaème:
	\begin{itemize}
		\item
		Funkcie $S_{ij}$ nazveme \pojem{segmenty splajnu}.
		\item
		Dvojice $(u_i, v_j)$ nazveme \pojem{uzly}.
		\item
		Uzly $(u_0, v_0)$, $(u_{I-1}, v_0)$, $(u_0, v_{J-1})$ a $(u_{I-1}, v_{J-1})$ nazveme \pojem{rohové uzly}.
		\item
		$z_{i,j} = S(u_i, v_j)$ nazveme \pojem{funkèné hodnoty splajnu v uzloch}.
		\item
		$d^x_{i,j} = \pd{S(u_i, v_j)}{x}$ nazveme \pojem{$x$-ové derivácie v uzloch}.
		\item
		$d^y_{i,j} = \pd{S(u_i, v_j)}{y}$ nazveme \pojem{$y$-ové derivácie v uzloch}.
		\item
		$d^{xy}_{i,j} = \pdd{S(u_i, v_j)}{x}{y}$ nazveme \pojem{zmiešané derivácie v uzloch}.
		\item
		$h_x = u_i - u_{i-1}$ a $h_y = v_j - v_{j-1}$ pre ¾ubovo¾né $i \in  \{1, \dots, I-1\}$, resp. $j \in  \{1, \dots, J-1\}$.
	\end{itemize}
}
Prirodzene vidie, e takto definovanı krivkovı a povrchovı splajn je triedy $C^1$. 
Pri vhodne zvolenıch hodnotách derivácií v uzloch vieme ale zaruèi rovnos aj druhıch derivácií, èim dostaneme splajn z triedy $C^2$ èo nám zaruèí hladkos \uv{spojenia} jednotlivıch segmentov. 
Ak uvaujeme ¾ubovo¾nú funkciu tak pomocou nej vieme nájs iadané hodnoty derivácií. 
Navyše takto získanı splajn bude danú funkciu interpolova, teda ju \uv{napodobní}. 
To je iadané napríklad v grafickom modelovaní, pretoe pre poèítaè je jednoduchšie a rıchlejšie pracova s polynómom interpolujúcim napríklad goniometrickú funkciu ako priamo s òou. Navyše sa dá ukáza, e interpolácia funkcie splajnom je jednoznaèná. 
Témou tejto práce sú práve metódy vıpoètu prvıch derivácií, ktorımi je moné dosiahnu práve spomenutı cie¾.

Témou následovnıch èastiach práce je úloha na základe vstupnıch uzlov a funkcie $d: \mathbb{R} \times \mathbb{R} \to \mathbb{R}$ nájs \pojem{hladkú}, po èastiach definovanú funkciu $S: [u_0, u_{I+1}] \times [v_0, v_{J+1}] \to \mathbb{R}$ z so spojitımi deriváciami prvého aj druhého rádu takú, e pre kadé $i \in  {0, \dots, I-1}$ a $j \in  {0, \dots, J-1}$ platí $z_{i,j} = f(u_i, v_j)$ a hodnoty derivácií $S$ v uzloch sú èo najblišie hodnotám derivácií $f$. 
Funkciu $S$ nazıvame splajn (konkrétne povrchovı splajn), prièom jednotlivé èasti nazveme \pojem{segmenty}. 

\obrazok{fseg.png}{0.5}{\label{pic:fseg}Ukáka uzlov pre štvorsegmentovı splajn.}

Ak $i$ je z  $\{0, \dots, I-2\}$ a $j$ je z $\{0, \dots, J-2\}$, tak štvorice uzlov $(u_i, v_j)$, $(u_i, v_{j+1})$, $(u_{i+1}, v_j)$ a $(u_{i+1}, v_{j+1}$ tvoria obdånikovı úsek nad ktorım sa nachádza splajnovı segment. Kadı segment $S_{i,j}$ je bikubická funkcia z $[u_i, u_{i+1}] \times [v_j, v_{j+1}]$ do $\mathbb{R}$. 
Vısledná funkcia $S$ teda vznikne zjednotením segmentov $S_{i,j}$. 
Na vypoèítanie kadého segmentu potrebujeme štyri uzly, a pre kadı uzol príslušne hodnoty $z$, $d^x$, $d^y$ a $d^{xy}$. 
Tieto hodnoty vieme získa buï priamo z interpolovanej funkcie $f$, alebo ich vypoèíta inım spôsobom, napríklad De Boorovou interpoláciou. 

\section{Trojdiagonálna LU dekompozícia}

\begin{df}
	Nech $n \ge 3$ je z \uinteger. Sústavu rovníc tvaru
	\begin{equation}\label{eq:lu}
	\begin{pmatrix}
	b_1 & a_1 & 0 & \hdots & 0 & 0\\
	c_1 & b_2 & a_2 & \hdots & 0 & 0\\
	0 & c_2 & b & \hdots & 0 & 0\\
	\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
	0 & 0 & 0 & \hdots & b & a_{n-1} \\
	0 & 0 & 0 & \hdots & c_{n-1} & b_n\\
	\end{pmatrix} 
	\cdot
	\begin{pmatrix}
	x_1\\
	x_2\\
	x_3\\
	\vdots \\
	x_{n-1}\\
	x_{n}\\
	\end{pmatrix}
	=
	\begin{pmatrix}
	r_1\\
	r_2\\
	r_3\\
	\vdots \\
	r_{n-1}\\
	r_{n}\\
	\end{pmatrix}
	\end{equation}
	nazveme \pojem{trojdiagonálna sústava lineárnych rovníc}.
\end{df}

Základ oboch postupoch tkvie v opakovanom poèítaní systémov trojdiagonálnych lineárnych rovníc. 
Jeden so spôsobov riešenia tıchto rovníc

%\begin{equation}\label{eq:lu}
%\begin{pmatrix}
%b & 1 & 0 & \hdots & 0 & 0\\
%1 & b & 1 & \hdots & 0 & 0\\
%0 & 1 & b & \hdots & 0 & 0\\
%\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
%0 & 0 & 0 & \hdots & b & 1 \\
%0 & 0 & 0 & \hdots & 1 & b\\
%\end{pmatrix} 
%\cdot
%\begin{pmatrix}
%d_1\\
%d_2\\
%d_3\\
%\vdots \\
%d_{K-2}\\
%d_{K-1}\\
%\end{pmatrix}
%=
%\begin{pmatrix}
%r_0 - d_0\\
%r_1\\
%r_2\\
%\vdots \\
%r_{K-2}\\
%r_{K-1} - d_{K-1}\\
%\end{pmatrix}\text{,}
%\end{equation}
spoèíva v $LU$ dekompozícii $A\mathbf{x} = L\underbrace{U\mathbf{x}}_{\mathbf{y}} = \mathbf{r}$:
%spytat sa docenta: preco LU a b
\begin{equation}
A = 
\begin{pmatrix}
1 & 0 & 0 & \hdots & 0 & 0\\
\lambda_2 & 1 & 0 & \hdots & 0 & 0\\
0 & \lambda_3 & 1 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & 1 & 0 \\
0 & 0 & 0 & \hdots & \lambda_{n} & 1\\
\end{pmatrix} \cdot
\begin{pmatrix}
\upsilon_1 & 1 & 0 & \hdots & 0 & 0\\
0 & \upsilon_1 & 1 & \hdots & 0 & 0\\
0 & 0 & \upsilon_2 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & \upsilon_{n-1} & 0 \\
0 & 0 & 0 & \hdots & 0 & \upsilon_n\\
\end{pmatrix}\text{,}
\end{equation}
Pre $k$ z $\{2, \dots, n\}$ sú hodnoty $\upsilon_k$ a $\lambda_k$ urèené takto:

\begin{equation} \label{eq:LU}
\upsilon_i = b \text{,} \left\{ \lambda_i = \frac{1}{\upsilon_{i-1}}, \upsilon = b - \lambda_i\right\} \text{,} i \in \{2, \dots, n\}\text{.}
\end{equation}
Pre priamy a spätnı chod máme
\begin{equation} \label{eq:FwLy}
\text{Priamy: } L\mathbf{y} = \mathbf{r} \text{, } y_1 = r_1 \text{, } \left\{ y_i = r_i - \lambda_i\right\} \text{, } i \in \{2, \dots, n\}\text{,}
\end{equation}
\begin{equation} \label{eq:BwUd}
\text{Spätnı: } U\mathbf{d} = \mathbf{y} \text{, } d_i = \frac{y_i}{u_i} \text{, } \left\{ d_i = \frac{1}{u_i}(y_i - d_{i+1})\right\} \text{,} i \in \{n-1, \dots, 1\}\text{.}
\end{equation}
LU dekompozíciou sa rieši ako de Boorova sústava (\ref{eq:deboorM}), tak aj naša redukovaná (\ref{eq:redM}).

\section{De Boorova interpolácia}

Nech sú dané hodnoty $(u_0$, ...,$u_{I-1})$ a $(v_0$, ...,$v_{J-1})$, kde $I$,$J$ sú z \uinteger, prièom chceme interpolova funkciu $f$ na $[u_0, u_{I-1}] \times [v_0, v_{J-1}]$. 
Vıslednı splajn bude teda tvorenı $(I-1) \cdot (J-1)$ segmentami. 
Ako bolo spomenuté, kadı segment splajnu potrebuje štyri uzly a hodnoty $z$, $d^x$, $d^y$ a $d^{xy}$, ktoré potrebujeme získa z funkcie $f$. 
Získanie derivácií priamo z $f$ môe by v praxi na poèítaèi nákladné najmä v prípade, keï pracujeme so symbolicky zapísanou funkciou vo forme textového reazca, ktorú je potrebné interpretova. 

Algoritmus nájdenı Carlom de Boorom\cite{deboor} umoòuje s malou odchılkou odhadnú hodnoty derivácií v uzloch na základe tıchto vstupnıch hodnôt, ktoré potrebujeme získa vyhodnotením funkcie $f$:
\begin{itemize}\label{eq:deboor_input}
	\item
	$z_{i,j} = f(u_i,v_j)$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^x_{i,j} = \pd{f}{x}(u_i,v_j)$ pre $i \in \{0, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^y_{i,j }= \pd{f}{y}(u_i,v_j)$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, J-1\}$.
	\item
	$d^{xy}_{i,j} = \pdd{f}{x}{y}(u_i,v_j)$ pre $i \in \{0, I-1\}$, $j \in \{0, J-1\}$.
\end{itemize}
\pr{
Na príklade uzlov z obrázka \ref{pic:fseg} potrebujeme pozna hodnoty následovne:
\begin{itemize}
	\item
	$z_{0,2}$, $z_{1,2}$, $z_{2,2}$,\newline
	$z_{0,1}$, $z_{1,1}$, $z_{2,1}$,\newline
	$z_{0,0}$, $z_{1,0}$, $z_{2,0}$,\newline  
	\item
	$d^x_{0,2}$, \phantom{$d^x_{1,2}$}, $d^x_{2,2}$,\newline
	$d^x_{0,1}$, \phantom{$d^x_{1,1}$}, $d^x_{2,1}$,\newline
	$d^x_{0,0}$, \phantom{$d^x_{1,0}$}, $d^x_{2,0}$,\newline 
	\item
	$d^y_{0,2}$, $d^y_{1,2}$, $d^y_{2,2}$,\newline
	\phantom{$d^y_{0,1}$}, \phantom{$d^y_{1,1}$}, \phantom{$d^y_{2,1}$},\newline
	$d^y_{0,0}$, $d^y_{1,0}$, $d^y_{2,0}$,\newline
	\item
	$d^{xy}_{0,2}$, \phantom{$d^{xy}_{1,2}$}, $d^{xy}_{2,2}$,\newline
	\phantom{$d^{xy}_{0,1}$}, \phantom{$d^{xy}_{1,1}$}, \phantom{$d^{xy}_{2,1}$},\newline
	$d^{xy}_{0,0}$, \phantom{$d^{xy}_{1,0}$}, $d^{xy}_{2,0}$,\newline  
\end{itemize}
}
Zvyšné derivácie $d^x$, $d^y$ a $d^{xy}$ vieme jednoznaène vypoèíta pomocou $2(I) + J + 5$ lineárnych sústav s celkovo $3IJ + I + J + 2$ rovnicami:
Nišie uvádzame modelové rovnice, pomocou ktorıch sú zostrojené tieto sústavy lineárnych rovníc.
\newline\newline
Pre $j \in \{0, \dots, J-1\}$, teda pre kadı ståpec $j$ vypoèítame parciálne derivácie $d^x$
\begin{equation}\label{eq:deboor1}
\begin{split}
d^x_{i+1,j} + 4d^x_{i,j} + d^x_{i-1,j}
= \frac{3}{h_x}(z_{i+1,j} - z_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $j \in \{0, J-1\}$, teda pre prvı a poslednı ståpec vypoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:deboor2}
\begin{split}
d^{xy}_{i+1,j} + 4d^{xy}_{i,j} + d^{xy}_{i-1,j}
= \frac{3}{h_x}(d^y_{i+1,j} - d^y_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $i$ vypoèítame parciálne derivácie $d^y$
\begin{equation}\label{eq:deboor3}
\begin{split}
d^y_{i,j+1} + 4d^y_{i,j} + d^y_{i,j-1}
= \frac{3}{h_y}(z_{i,j+1} - z_{i,j-1}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $j$ dopoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:deboor4}
\begin{split}
d^{xy}_{i,j+1} + 4d^{xy}_{i,j} + d^{xy}_{i,j-1}
= \frac{3}{h_y}(d^x_{i,j+1} - d^x_{i,j-1}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
\newline
Kadá z tıchto sústav má takıto maticovı tvar:

\begin{equation} \label{eq:deboorM}
\begin{pmatrix}
4 & 1 & 0 & \hdots & 0 & 0\\
1 & 4 & 1 & \hdots & 0 & 0\\
0 & 1 & 4 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & 4 & 1\\
0 & 0 & 0 & \hdots & 1 & 4\\
\end{pmatrix}
\cdot
\begin{pmatrix}
D_{1}\\
D_{2}\\
D_{3}\\
\vdots \\
D_{N-3}\\
D_{N-2}\\
\end{pmatrix}
=
\begin{pmatrix}
\frac{3}{\Delta}(Y_{2} - Y_{0}) - D_0\\
\frac{3}{\Delta}(Y_{3} - Y_{1})\\
\frac{3}{\Delta}(Y_{4} - Y_{2})\\
\vdots \\
\frac{3}{\Delta}(Y_{N-2} - Y_{N-4})\\
\frac{3}{\Delta}(Y_{N-1} - Y_{N-3}) - D_{N-1}\\
\end{pmatrix} \text{,}
\end{equation}
kde pod¾a toho o ktorú z modelovıch rovníc sa jedná, hodnoty N, D a Y zadávame následovne. 
Nech $k$ z ${1, \dots, K-1}$:
\begin{itemize}
	\item
	$N = I$, $h= h_x$,  $D_k = d^x_{k,j}$ a $Y_k = z_{k,j}$, pre rovnicu \ref{eq:deboor1}.
	\item
	$N = I$, $h= h_x$,  $D_k = d^{xy}_{k,j}$ a $Y_k = d^y_{k,j}$, pre rovnicu \ref{eq:deboor2}.
	\item
	$N = J$, $h= h_y$,  $D_k = d^y_{i,k}$ a $Y_k = z_{i,k}$, pre rovnicu \ref{eq:deboor3}.
	\item
	$N = J$, $h= h_y$,  $D_k = d^{xy}_{i,k}$ a $Y_k = d^x_{i,k}$, pre rovnicu \ref{eq:deboor3}.
\end{itemize}

Po vypoèítaní všetkıch derivácií môeme funkciu jednoznaène interpolova splajnom.

\pozn{
V aplikácií na vizualizáciu pouívame práve Hermitove splajny.
}
%TO_CSABA: Preco hermitove?

\pozn{
De Boorova interpolácia vo všeobecnosti nepredpokladá len rovnomerne rastúce postupnosti uzlov $(u_0$, ...,$u_I)$ a $(v_0$, ...,$v_J)$. 
Náš postup v ïalšej èasti èlánku ale funguje len s takımito postupnosami. 
Preto sme v tejto èasti popísali len špeciálny prípad interpolácie pre takto urèené uzly.
}

\section{Poèítanie derivácií redukovanou sústavou}

V rámci svojej bakalárskej práce som popisoval novı postup pre kubické splajnové krivky triedy C2, teda splajny, kde interpolovaná funkcia $f$ je typu $\mathbb{R} \to \mathbb{R}$. 
Cie¾om tejto práce je postup zovšeobecni pre bikubické splajny, teda pre splajny, kde interpolovaná funkcia $f$ je typu $\mathbb{R} \times \mathbb{R} \to \mathbb{R}$.

\begin{oznac}
 Teraz popíšeme tento rozšírenı algoritmus, ktorı pracovne oznaèíme ako \pojem{redukovanı algoritmus}. 
 Ïalej budeme pôvodnı de Boorov postup, oznaèova pojmom \pojem{plnı algoritmus}.
\end{oznac}

Vstupné hodnoty sú identické ako pri pôvodnom algoritme. 
Máme dané $(u_0$, ...,$u_{I-1})$ a $(v_0$, ...,$v_{J-1})$, kde $I$,$J$ sú z \uinteger, prièom chceme interpolova funkciu $f$ na $[u_0, u_{I-1}] \times [v_0, v_{J-1}]$. 
Pre pripomenutie potrebujeme z funkcie $f$ priamo získa tieto hodnoty.
\begin{itemize}
	\item
	$z_{i,j} = f(u_i,v_i)$, pre $i \in \{0, \dots, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^x_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^y_{i,j}$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, J-1\}$.
	\item
	$d^{xy}_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, J-1\}$.
\end{itemize}  
Zvyšné derivácie $d^x$, $d^y$ a $d^{xy}$ vieme jednoznaène vypoèíta pomocou $2(I) + J + 5$ lineárnych sústav s celkovo $3IJ + I + J + 2$ rovnicami:
Nišie uvádzame modelové rovnice, pomocou ktorıch sú zostrojené tieto sústavy lineárnych rovníc. 
Oznaème $I_l$ a $J_l$ indexy po ktoré budeme iterova. 
Platí:
$$I_l = \begin{cases}
I - 2 & \text{ak } I \text{ je nepárne,}\\
I - 3 & \text{ak } I \text{ je párne,}
\end{cases}$$
\item
$$J_l = \begin{cases}
J - 2 & \text{ak } J \text{ je nepárne,}\\
J - 3 & \text{ak } J \text{ je párne,}
\end{cases}$$

Pre $j \in \{0, \dots, J-1\}$, teda pre kadı ståpec $j$ vypoèítame parciálne derivácie $d^x$
\begin{equation}\label{eq:red1}
\begin{split}
d^x_{i+2,j} - 14d^x_{i,j} + d^x_{i-2,j}
= \frac{3}{h_x}(z_{i+2,j} - z_{i-2,j}) - \frac{12}{h_x}(z_{i+1,j} - z_{i-1,j}) \text{, }\\ i \in \{2,4 \dots, I_l\}
\end{split}
\end{equation}
Rovnica je podobná ako plnom algoritme \ref{eq:deboor1}. 
Všimnime si, e sústavu rovníc teraz budujeme len pre párne indexy $i$, teda vyriešením tejto sústavy
získame iba polovicu iadanıch hodnôt $d^x$. 
Pre $i \in \{1,3 \dots, I_l\}$ a $j \in \{0, \dots, J-1\}$ zvyšné derivácie $d^x$ vypoèítame ako
\begin{equation}\label{eq:redr1}
d^x_{i,j} = \frac{3}{4h_x}(z_{i+1,j} - z_{i-1,j}) - \frac{1}{4}(d^x_{i+1,j} - d^x_{i-1,j})
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $i$ analogicky vypoèítame parciálne derivácie $d^y$
\begin{equation}\label{eq:red2}
\begin{split}
d^y_{i,j+2} - 14d^x_{i,j} + d^x_{i,j-2}
= \frac{3}{h_y}(z_{i,j+2} - z_{i,j+2}) - \frac{12}{h_y}(z_{i,j+1} - z_{i,j-1}) \text{, }\\ i \in \{2,4 \dots, I_l\}
\end{split}
\end{equation}
Následne analogicky pre $i \in \{1,2, \dots, I-1\}$ a $j \in \{1,3, \dots, J_l\}$ zvyšné derivácie $d^y$ vypoèítame ako
\begin{equation}\label{eq:redr2}
d^y_{i,j} = \frac{3}{4h_y}(z_{i,j+1} - z_{i,j-1}) - \frac{1}{4}(d^y_{i,j+1} - d^y_{i,j-1})
\end{equation}
Pre $j \in \{0, J-1\}$, teda pre prvı a poslednı ståpec vypoèítame parciálne derivácie $d^{x,y}$ rovnako ako pri plnom algoritme.
\begin{equation}\label{eq:red3a}
\begin{split}
d^{xy}_{i+1,j} + 4d^{xy}_{i,j} + d^{xy}_{i-1,j}
= \frac{3}{h_x}(d^y_{i+1,j} - d^y_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $i \in \{0, I-1\}$, teda pre prvı a poslednı riadok analogicky vypoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:red3b}
\begin{split}
d^{xy}_{i,j+1} + 4d^{xy}_{i,j} + d^{xy}_{i,j-1}
= \frac{3}{h_y}(d^x_{i,j-1} - d^x_{i-1,j}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
Pre $i \in \{2,4, \dots, I_l\}$, teda pre kadı ståpec $i$ dopoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:red4}
\begin{split}
&d^{xy}_{i,j+2} + 4d^{xy}_{i,j} + d^{xy}_{i,j-2} =\\
&\frac{1}{7}(d^{xy}_{i-2,j+2} - d^{xy}_{i-2,j-2}) - 2d^{xy}_{i-2,j}\\
&+\frac{3}{7h_x}(d^y_{i-2,j+2} - d^y_{i-2,j-2}) + \frac{3}{7h_y}(-d^x_{i-2,j+2} - d^x_{i-2,j-2})\\
&+\frac{9}{7h_x}(d^y_{i,j+2} - d^y_{i,j-2}) + \frac{9}{7h_x h_y}(-z_{i-2,j+2} + z_{i-2,j-2})\\
&+\frac{12}{7h_x}(-d^y_{i-1,j+2} - d^y_{i-1,j-2}) + \frac{12}{7h_y}(d^x_{i-2,j+1} - d^x_{i-2,j-1})\\
&+\frac{3}{7h_y}(d^x_{i,j+2} - d^x_{i,j-2}) + \frac{27}{7h_x h_y}(-z_{i,j+2} + z_{i,j-2})\\
&+\frac{36}{7h_x h_y}(z_{i-1,j+2} - z_{i-1,j-2} + z_{i-2,j+1} - z_{i-,j-1})\\
&-\frac{6}{h_x}d^y_{i-2,j} + \frac{144}{7h_x h_y}(-z_{i-1,j+1} + z_{i-1,j-1})
+\frac{24}{h_x}d^y_{i-1,j}
\text{, }\\ & j \in \{4,6 \dots, J_l-2\}
\end{split}
\end{equation}
Následne vypoèítame zvyšné derivácie $d^{x,y}$.
Najprv pre $i \in \{1,3, \dots, I_l\}$ a $j \in \{1,3, \dots, J_l\}$ platí
\begin{equation}\label{eq:redr4a}
\begin{split}
d^{xy}_{i,j} &= \frac{1}{16}(d^{xy}_{i+1,j+1} + d^{xy}_{i+1,j-1} + d^{xy}_{i-1,j+1} + d^{xy}_{i-1,j-1})\\
&-\frac{3}{16h_y}(d^{x}_{i+1,j+1} - d^{x}_{i+1,j-1} + d^{x}_{i-1,j+1} - d^{x}_{i-1,j-1})\\
&-\frac{3}{16h_x}(d^{y}_{i+1,j+1} + d^{y}_{i+1,j-1} - d^{y}_{i-1,j+1} - d^{y}_{i-1,j-1})\\
&+\frac{9}{16h_x h_y}(z_{i+1,j+1} - z_{i+1,j-1} - z_{i-1,j+1} + z_{i-1,j-1})\text{. }
\end{split}
\end{equation}
Nakoniec pre $i \in \{1,3, \dots, I_l+1\}$ a $j \in \{2,4, \dots, J_l\}$
\begin{equation}\label{eq:redr4b}
d^{xy}_{i,j} = \frac{3}{4h_y}(d^x_{i,j+1} - zd^x_{i,j-1}) - \frac{1}{4}(d^{xy}_{i,j+1} - d^{xy}_{i,j-1})
\end{equation}
a pre $i \in \{2,4, \dots, I_l\}$ a $j \in \{1,3, \dots, J_l+1\}$
\begin{equation}\label{eq:redr4c}
d^{xy}_{i,j} = \frac{3}{4h_y}(d^x_{i,j+1} - zd^x_{i,j-1}) - \frac{1}{4}(d^{xy}_{i,j+1} - d^{xy}_{i,j-1})
\end{equation}
\oznac{
	Zaveïme dve oznaèenia.
	\begin{itemize}
	\item
	Rovnice \ref{eq:redr1}, \ref{eq:redr2} budeme súhrne oznaèova pojmom \pojem{resty}.
	\item
	Rovnice \ref{eq:redr4a}, \ref{eq:redr4b}, \ref{eq:redr4c} budeme súhrne oznaèova pojmom \pojem{zmiešané resty}.
	\end{itemize}
}

Modelové sústavy rovníc \ref{eq:red1} a \ref{eq:red2} majú takıto maticovı tvar:
\begin{equation} \label{eq:redM}
\begin{aligned}
\begin{pmatrix}
-14 & 1 & 0 & \hdots & 0 & 0\\
1 & -14 & 1 & \hdots & 0 & 0\\
0 & 1 & -14 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & -14 & 1 \\
0 & 0 & 0 & \hdots & 1 & \mu\\
\end{pmatrix} 
\cdot
\begin{pmatrix}
D_2\\
D_4\\
D_6\\
\vdots \\
D_{v-2}\\
D_{v}\\
\end{pmatrix}
=\\
\begin{pmatrix}
\frac{3}{h}(Y_4 - Y_0) - \frac{12}{h}(Y_3 - Y_1) - D_0\\
\frac{3}{h}(Y_6 - Y_2) - \frac{12}{h}(Y_5 - Y_3)\\
\frac{3}{h}(Y_8 - Y_4) - \frac{12}{h}(Y_7 - Y_5)\\
\vdots \\
\frac{3}{h}(Y_\nu - Y_{\nu-4}) - \frac{12}{h}(Y_{\nu-3} - Y_{\nu-5})\\
\frac{3}{h}(Y_{\nu+\tau} - Y_{\nu-2}) - \frac{12}{h}(Y_{\nu-1} - Y_{\nu-3} - \theta D_{K+1})\\
\end{pmatrix}\text{,}
\end{aligned}
\end{equation}
kde 
\begin{gather} \label{eq:reducedOddD}
\begin{aligned}
%\begin{split}
\mu &= -15\text{, }\tau = 0\text{, }\theta = -4\text{, a }\nu = N \text{,}&\text{ak }K\text{ je párne,}\\
\mu &= -14\text{, }\tau = 2\text{, }\theta = 1\text{, a }\nu = N - 1 \text{,}&\text{ak }N\text{ je nepárne,}
%\end{split}
\end{aligned}
\end{gather}
a pod¾a toho o ktorú z modelovıch rovníc sa jedná, hodnoty N, D a Y zadávame následovne. 
Nech $k$ z ${1, \dots, K-1}$:
\begin{itemize}
	\item
	$N = I$, $h= h_x$,  $D_k = d^x_{k,j}$ a $Y_k = z_{k,j}$, pre rovnicu \ref{eq:red1}..
	\item
	$N = J$, $h= h_y$,  $D_k = d^y_{i,k}$ a $Y_k = z_{i,k}$, pre rovnicu \ref{eq:red2}.
\end{itemize}
Analogicky vieme zostroji maticovı tvar aj pre modelovú sústavu pre derivácie $d^{xy}$ pod¾a \ref{eq:red4}.
\begin{oznac}
Špeciálne zaveïme oznaèenia pre tieto hodnoty:
\begin{itemize}
\item
Parciálne derivácie $d^x$ a $d^y$ poèítané rovnicami \ref{eq:redr1} a \ref{eq:redr2} budeme nazıva \pojem{zbytkové derivácie}.
\item
Zmiešané parciálne derivácie $d^xy$ poèítané rovnicami \ref{eq:redr4a}, \ref{eq:redr4b} a \ref{eq:redr4c} budeme nazıva \pojem{zmiešané zbytkové derivácie}.	
\end{itemize}	
\end{oznac}
%Hodnoty $D_k$ pre nepárne $k$ vypoèítame takto:
%\begin{multline} \label{eq:reducedR}
%D_k = \frac{1}{4}\left(\frac{3}{\Delta}(Y_{k+1} - Y_{k-1}) - D_{k-1} - D_{k+1}\right)\text{, } k \in \{1, 3, \dots, \nu + \tau - 1\}
%\end{multline}
%
%Pri kubickıch splajnoch teda potrebujume vypoèíta len prvé derivácie $D_0$, ..., $D_{K+1}$ v uzloch $u_0$, ..., $u_{K+1}$. 
%Pri bikubickıch povrchoch máme na základe de Boora 4 typy sústav, kde postupne rátame parciálne derivácie $\partial x$ a $\partial y$, prièom dvomi typmi z tıchto sústav vypoèítame parciálne derivácie $\partial xy$. 

\begin{lema}
	Splajn $S$ s takto definovanımi segmentami a deriváciami v uzloch vypoèítanıch pod¾a plného alebo pod¾a redukovaného algoritmu je triedy $C^2$ a interpoluje funkciu $f$.
\end{lema}

\section{Konštrukcia splajnu}

Teraz si ukáeme ako pod¾a zadanıch uzlov a vypoèítanıch derivácií zostroji segmenty splajnu ako funkcie dvoch premennıch v priestore.
Predpokladajme $I \ge 3$ a $J  \ge 3$ z \uinteger, rovnomerné uzly $u_0$, \dots, $u_{I-1}$ a $v_0$, \dots, $v_{J-1}$, funkciu dvoch premennıch $f:[u_0, u_{I-1}] \times [v_0, v_{J-1}] \to \mathbb{R}$. 
Úlohou je zostroji splajn $S$ triedy $C^2$ interpolujúci funkciu $f$.
Polome
\begin{itemize}
	\item
	funkèné hodnoty splajnu $z_{0,0}$, \dots, $z_{I-1,0}$, \dots, $z_{0,J-1}$, \dots, $z_{I-1,J-1}$, 
	\item
	$x$-ové derivácie splajnu  $d^x_{0,0}$, \dots, $d^x_{I-1,0}$, \dots, $d^x_{0,J-1}$, \dots, $d^x_{I-1,J-1}$,
	\item
	$y$-ové derivácie splajnu  $d^y_{0,0}$, \dots, $d^y_{I-1,0}$, \dots, $d^y_{0,J-1}$, \dots, $d^y_{I-1,J-1}$,
	\item
	$x$-ové derivácie splajnu  $d^{xy}_{0,0}$, \dots, $d^{xy}_{I-1,0}$, \dots, $d^{xy}_{0,J-1}$, \dots, $d^{xy}_{I-1,J-1}$,
\end{itemize}
a inicializujme ich pod¾a \ref{eq:deboor_input}.

Ïalším krokom je vypoèítanie zvyšnıch hodnôt derivácií buï plnım alebo redukovanım algoritmom. 
Vıstupom oboch sú rovnaké hodnoty derivácií, ktoré nám zaruèia spojitos a hladkos medzi jednotlivımi segmentami budovaného splajnu, èím pod¾a definície bude patri práve do triedy $C^2$.

Teraz u máme všetky potrebné hodnoty aby sme mohli definova segmenty splajnu $S$ pod¾a definície \ref{df:surface_spline}. 
Pre kadé $i$ z $\{0, \dots, I-2\}$ a $j$ z $\{0, \dots, J-2\}$ polome segment $S_{i,j}: [u_i, v_j] \times [u_{i+1}, v_{j+1}] \to \mathbb{R}$ vzahom:
\begin{equation}
\begin{gathered}
S_{i,j}(x,y) =\\ \pmb{\lambda}^\text{T}(x, u_i, u_{i+1}) \cdot \pmb{\Phi}(u_i, u_{i+1}, v_j, v_{j+1}) \cdot \pmb{\lambda}(y, v_{j}, v_{j+1})\text{,}
\end{gathered}
\end{equation}
kde 
\begin{equation}
\begin{gathered}
\pmb{\lambda}(t, t_0, t_1) =\\ \left(\frac{(t-t_1)^2(1-2\frac{t-t_0}{t_0-t_1})}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(1-2\frac{t-t_1}{t_1-t_0})}{(t_1 - t_0)^2}, \frac{(t-t_1)^2(t-t_0)}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(t-t_1)}{(t_1 - t_0)^2} \right)^\text{T} \text{,}
\end{gathered}
\end{equation}

\begin{equation}
\begin{gathered}
\pmb{\Phi}(t_0, t_1, s_0, s_1) =\\ \left(\frac{(t-t_1)^2(1-2\frac{t-t_0}{t_0-t_1})}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(1-2\frac{t-t_1}{t_1-t_0})}{(t_1 - t_0)^2}, \frac{(t-t_1)^2(t-t_0)}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(t-t_1)}{(t_1 - t_0)^2} \right)^\text{T} \text{,}
\end{gathered}
\end{equation}


\chapter{Zrıchlenie}\label{spdup}

Èasová zloitos oboch algoritmov je rovnaká a síce $O(I\cdot J)$. 
Redukovanı algoritmus je však teoreticky, a aj prakticky (\ref{real_speedup}) rıchlejší, navyše s menšími pamäovımi nárokmi.
Keïe porovnávame asymptoticky rovnako rıchle algoritmy, musíme bra do úvahy vplyv \uv{nízkoúrovòovıch} operácií, 
konkrétne rıchlosti vıpoètu sèítania, násobenia, delenia a na koniec aj samotnı vplyv pamäovıch operácií èítania a zapisovania. 
V tejto kapitole si spoèítame poèty tıchto operácií.

Na modernıch procesoroch v prípade matematickıch operácií s plávajúcou desatinnou èiarkou platí, e sèítanie a násobenie sú podobne rıchle, prièom delenie je nieko¾konásobne pomalšie. 
Pamäové operácie sú pritom v závislosti od konkrétneho typu operaènej pamäte pribline dvadsanásobne pomalšie ako sèítanie, resp. násobenie.\footnote{V praxi sa aj vıpoèty rádovo tisícov uzlov èasto zmestia do vyrovnávacej pamäte procesora (\pojem{cache}). 
	V tom prípade sú pamäové operácie len $1\times$-$10\times$ pomalšie ako sèítanie.}  

\section{Procesorová architektúra}

Predtım ako zaèneme s poèítaním operácií je nutné objasni si ako moderné procesory narábajú s dátami a ako funguje aplikovanie vıpoètov.
Architektúry CPU prešli za posledné desaroèia znaènım vıvojom. 
V dnešnej dobe u nemono zvyšova vıpoètovú rıchlos hrubou silou zvyšovaním frekvencie. 
Moderné procesorové mikroarchitektúry èasto pouívajú rôzne optimalizaèné \uv{triky a finty} ako dosiahnu zlepšenie vıkonu a ktoré majú znaènı vplyv na reálne rıchlosti algoritmov. 
Dvomi takımi optimalizáciami sú takzvané kešovanie a inštrukènı paralelizmus.    

\subsection{Kešovanie}\label{sec:kesovanie}

Pri návrhu algoritmu je vhodné si uvedomi tvar dátovıch štruktúr do ktorıch pri reálnej implementácií budeme uklada funkèné hodnoty, uzly a derivácie.
Naša implementácia v prípade kriviek pouíva klasické vektory, teda polia. 
 povrchoch sa hodnoty reprezentujú maticami. 
 Maticu je moné interpretova buï ako \uv{pole polí} respektíve \uv{vektor vektorov} (anglicky \uv{jagged array}), alebo ako jedno spojité pole, kde prvok na $i$-tom riadku a $j$-tom ståpci má v takejto reprezentácii index $n\cdot i+j$, kde $n$ je poèet ståpcov. 
 My budeme  v meraniach a vıpoètoch uvaova práve prvú reprezentáciu znázornenú na obrázku nišie.
\obrazok{jarr.png}{0.407}{Vizuálna reprezentácia dátovej štruktúry \uv{pole polí}.\label{obr:jagged_array}}

Operaèná pamä v dnešnıch poèítaèoch je rádovo pomalšia ako procesor, ktorı musí èaka desiatky a stovky strojovıch cyklov ak chce naèíta hodnotu z pamäte. 
Moderné procesory preto pouívajú systém malıch, ale rıchlych vyrovnávacích pamätí tzv. \textit{cache} do ktorıch sa prednaèítavajú dáta a strojové inštrukcie programu z operaènej pamäte, v ideálnom prípade skôr ako ich procesor bude potrebova. 
Toto kešovanie je plne automatickı proces riadenı samotnım CPU. 
Programátor má len nepriame monosti ovplyvnenia tohto procesu, napríklad vhodnım vıberom dátovıch štruktúr a podobne. 

Uvaujme maticu $m \times n$ typu pole polí ako z obrázka vyššie. 
Ak z matice naèítame prvok $a_{0,0}$ tak je vysoko pravdepodobné, e procesor následne bude ma nakešované aj prvky $a_{0,1}$, $a_{0,2}$ pretoe sú z jedného po¾a a teda sú v pamäti \uv{ved¾a seba} (CPU kešuje pamä po spojitıch blokoch), ale u nemusí ma kešovanı prvok $a_{1,0}$ lebo tento je u z iného po¾a a teda z úplne inej oblasti pamäte. 
Z toho v praxi vyplıva, e vıraz $a_{0,0} + a_{0,1}$ procesor vyhodnotí rıchlejšie ako vıraz $a_{0,0} + a_{1,0}$. 

Pozornı èitate¾ si môe všimnú, e v prípade pouitia druhej reprezentácie matice, teda jedného ve¾kého spojitého po¾a dåky $m \cdot n$, pravdepodobnos kešovania aj prvku $a_{1,0}$ by sa zvıšila, keïe je v tomto prípade sa bude nachádza v tom istom bloku pamäte ako prvok $a_{0,0}$ iba o $n$ prvkov (t.j. jeden celı ståpec) ïalej. 
Toto je pravda a všeobecne sa druhá menovaná reprezentácia povauje za efektívnejšiu vzh¾adom na procesorovı èas a pamä poèítaèa, ale to platí len pre malé matice najmä s malım poètom ståpcov $n$.

V aplikácii sme toti vyskúšali obe varianty reprezentácie a pre matice s rádovo $1000 \times 1000$ prvkami sa ako efektívnejšia ukazuje práve prvá reprezentácia, teda \uv{pole polí}. 
Toti ak jeden prvok matice má $8$ bajtov (ve¾kos èíselného typu \textit{double} vo väèšine jazykoch), tak matica zaberá v pamäti pribline $7\text{,}63$ megabajtov. 
Pri matici typu pole polí máme $1000$ polí kadé zaberajúce práve $7\text{,}81$ kilobajtov ($1$ kB = $1024$ B, $1$ MB = $1024$ kB, atï.). 
Pre CPU je kešovanie takıchto polí podstatne jednoduchšie ako v prípade matice reprezentovanej jednım po¾om, ktoré samotné má ve¾kos práve $7\text{,}63$ MB, èo presahuje kapacitu väèšiny vyrovnávacích pamätí.
Obrázok nišie názorne ukazuje vzah medzi ve¾kosou dátovej štruktúry v kB a poètom strojovıch cyklov, ktoré procesor musí èaka pre prístup k jej prvkom. 
Ako vidie do pri dosiahnutí ve¾kosti $32$ kB, dáta sú namiesto ve¾mi rıchlej vyrovnávacej pamäte L1 kešované do trojnásobne pomalšej vyrovnávacej pamäte L2 atï..

\obrazok{cacheIntel.png}{0.6}{Graf rıchlosti prístupu k dátam rôznych ve¾kostí na modernıch CPU\cite{cacheIntel}.\label{img:cacheSpeed}}

\subsection{Inštrukènı paralelizmus}\label{sec:instrukcny_paralelizmus}

V poslednıch rokoch sa v poèítaèovej vede stále viac spomína pojem paralelizmu. 
Dnešné procesory architektúry x86 vyuívajú a štyri úrovne paralelizácie vıpoètov. 
Na najvyššej úrovni hovoríme o návrhu kedy je procesor zloenı z nieko¾kıch autonómne pracujúcich \uv{podprocesorov} nazıvanıch \pojem{jadrá}. 
Tie zdie¾ajú systémové zbernice a pamä prièom majú väèšinou vlastnú L1 alebo L2 cache. 
Kadé jadro môe spracováva na sebe nezávislé procesy prípadne jeden proces môe by rozdelenı do takzvanıch vlákien, kde kadé môe by spracovávané inım jadrom. 
V tomto prípade hovoríme o takzvanom \pojem{vláknovom paralelizme} s ktorım sa stretávame najmä pri programovaní vo vyšších jazykoch. 
V našej implementácie testujeme vláknovo paralelizované aj klasické sériové verzie algoritmov.  

Ïalšie úrovne paralelizácie majú spoloèné oznaèenie \pojem{inštrukènı paralelizmus}. 
Pod tımto pojmom rozumieme \pojem{superskalárnos}, \pojem{pipelining} a \pojem{vektorizácia}. 
Pri tejto úrovni paralelizmu má programátor len obmedzené monosti jeho ovplyvnenia, všetku \uv{akú} prácu obstará prekladaè a pri behu aplikácie zasa inštrukènı plánovaè v samotnom procesorovom jadre. 

Hlavnı vplyv na vıkon plného a najmä redukovaného algoritmu má superskalárnos. 
Najprv si vysvetlime èo tento pojem znamená. 
Jadro je tvorené nieko¾kımi a desiatkami špecializovanımi jednotkami ako sú aritmeticko logické jednotky (ALU), bitové posuvníky (Shift), numerické koprocesory (FPU) a podobne.
Narozdiel od celıch jadier pri vláknovom paralelizme, 
tieto jednotky vo všeobecnosti nedokáu fungova samostatne a simultánne spracováva viacero vlákien alebo procesov\footnote{Existujú technológie ako napríklad Hyper-threading umoòujúce za urèitıch podmienok uplatni vláknovı paralelizmus aj v rámci jediného superskalárneho jadra.}. 
Vedia iba v rámci jedného vlákna, za splnenia urèitıch podmienok, spracováva nieko¾ko inštrukcií naraz. Nutnou podmienkou je napríklad vzájomná nezávislos nieko¾kıch po sebe idúcich inštrukcií, teda keï vısledok jednej inštrukcie nezávisí na vısledku predchádzajúcej.

Tu ale paralelizácia nekonèí. 
Aj samotné jednotky toti dokáu simultánne spracováva viac ne jeden dátovı vstup. 
Na tejto úrovni rozlišujeme medzi vektorizáciou, a pipeliningom. 
Prvá menovaná technika umoòuje jednu inštrukciu aplikova na celé vektory, resp. polia. 
Z povahy vıpoètov v našej práci nás ale vektorizácia nemusí zaujíma èo si vysvetlíme neskôr. 
Pipelining je zaloenı na myšlienke princípu fungovania vıpoètovıch jednotiek podobne ako vırobná linka vo fabrike, kde novı vırobok na linku vstúpi skôr ako je predchádzajúci dokonèenı. 
Teda aj väèšina vıpoètovıch jednotiek dokáe s novım vıpoètom zaèa ešte pred dokonèením práve prebiehajúcej operácie.

\obrazok{skylakeCore.png}{0.6}{Schéma vıpoètového jadra mikroarchitektúry Intel Skylake\cite{intelOpt}.\label{obr:skylakeCore}}

Spomenuli sme majoritnı vplyv superskalárnosti. 
Na obrázku \ref{obr:skylakeCore} vidíme schému jedného jadra procesorovej mikroarchitektúry Intel Skylake, ktorá je ku dòu písania práce najmodernejšou bene dostupnou procesorovou generáciou a na ktorej testujeme náš zrıchlenie redukovaného algoritmu. 
Jadrá (nielen) tejto architektúry sú vybavené dvomi sèítaèko-násobièkami èísiel s plávajúcou desatinnou èiarkou, ktoré sú na obrázku zvıraznené èervenou farbou. 
Pointa superskalárnosti v tomto prípade spoèíva v monosti vıpoèet vırazov typu $a_0\circ a_1\circ\dots\circ a_n$, kde $\circ \in \{+, \cdot\}$ rozloi medzi dve jednotky a dosiahnu dvojnásobného zrıchlenia. 
Toto má znaènı vplyv na rıchlos najmä redukovaného algoritmu pri poèítaní pravıch strán trojdiagonálnych rovníc, ktoré sú na prvı poh¾ad zloitejšie ako v prípade plného algoritmu. 
Keïe procesor má ale iba jednu delièku, pre vırazy typu $a_0 / a_1 /\dots / a_n$ takıto trik fungova nebude.

Procesorové jadro na obrázku vyššie má svojich 29 jednotiek prístupnıch cez osem zberníc (porty 0 a 7). To konkrétne v prípade procesorov Skylake znamená, e dokáu naraz vyuíva maximálne osem svojich vıpoètovıch jednotiek za splnenia urèitıch podmienok. 

Málokedy ale proces alebo vlákno obsahuje vdy osmice vzájomne nezávislıch inštrukcií. 
V situácií kedy jeden proces (vlákno) nemôe vyui všetky jednotky jadra, niektoré procesory umoòujú nevyuité porty priradi inému procesu (vláknu). 
Táto technika sa nazıva \pojem{Simultaneous Multi-Threading} (ïalej len SMT). 
V literatúre sa, v prípade procesoroch Intelu, èasto môeme stretnú s názvom \pojem{Hyper-Threading}. 
Procesory AMD majú implementovanı odlišnı variant tejto techniky zvanı \pojem{Clustered Multi-Threading}, kde namiesto klasickıch jadier je procesor vybavenı tzv. modulmi, kde kadı modul má dve samostatné \uv{oklieštené} jadrá schopné spracováva iba celoèíselné operácie a jedinú FPU jednotku spoloènú pre oba jadrá. 
V praxi teda SMT predstavuje akısi medzistupeò medzi vláknovım a inštrukènım paralelizmom, 
kedy procesor operaènému systému a beiacim procesom hlási väèší poèet jadier akım je v skutoènosti vybavenı, prièom interne na úrovni mikroarchitektúry sa jedná iba o ïalšiu techniku superskalárnosti.
 
SMT má vırazne pozitívny vplyv na vıkon procesora ak procesy (vlákna) zdie¾ajúce jedno jadro nepoadujú prístup k tım istım jednotkám. 
V opaènom prípade dochádza k javu kedy jeden proces (vlákno) musí èaka na uvo¾nenie jednotky druhám procesom (vláknom) a vtedy môe dôjs k zníeniu vıkonu oproti identickému procesor s neaktívnym SMT.
V praktickıch meraniach má SMT na implementované algoritmy negatívny vplyv. 

\subsection{Rıchlos aritmetickıch operácií}\label{sec:instr_rychlost}

Procesory majú mnoho aritmetickıch jednotiek špecializovanıch na urèitı typ operácie. 
Je prirodzené predpoklada, e tieto jednotky budú pracova navzájom rozliènımi rıchlosami. 
V prípade vıpoètovıch algoritmov má pochopite¾ne okrem vıberu vhodnıch dátovıch štruktúr vplyv najmä rıchlos vykonania základnıch matematickıch operácií a síce sèítania, odèítania, násobenia a delenia. 

Najlepším zdrojom ako zisti rıchlos tıchto operácií je dokumentácia inštrukènıch sád procesorov.
Inštrukèná sada x86 sa od svojho prvotného uvedenia v roku 1978 doèkala mnohıch rozšírení. 
Moderné procesory obsahujú mnoho spôsobov ako napríklad vynásobi dve èísla. 
Keïe nie je v silách otestova všetky moné rozšírenia sady, zvolili sme si jedno konkrétne rozšírenie a síce Streaming SIMD Extensions (skrátene SSE), konkrétne vo verzii 4 (SSE4). 
Sady z rodiny SSE sú v èase písania práce najpouívanejšími sadami (najmä SSE2) ktoré sú podporované prakticky všetkımi nemuzeálnymi procesormi. 

V súèasnosti u existuje modernejšia náhrada tejto sady zvaná Advanced Vector Extensions (skratka AVX), ktorej hlavnı prínos spoèíva vo vylepšenıch vektorovıch operáciach. 
Vektorové operácie vyadujú aby vıpoèty vyuívajúce jednotlivé prvky vektora boli navzájom nezávislé. 
To nie je prípad ani jedného z testovanıch algoritmov. 
Nakonfigurovaním prekladaèa na generovanie tıchto inštrukcí by sme iba znemonili beh aplikácie na polovici z testovanıch procesorov. 
Praktické zrıchlenie sme testovali na šiestich procesoroch architektúry x86, prièom sme pokryli väèšinu mikroarchitektúr v rozmedzí rokoch 2007 a 2015.

V následujúcej tabu¾ke\cite{instrTables} uvidíme rıchlosti štyroch základnıch matematickıch operácií v rámci šiestich testovanıch mikroarchitektúr. 
Tabu¾ka obashuje tieto ståpce.
\begin{itemize}
	\item \textbf{Architektúra (rok)}\newline
	Testovaná mikroarchitektúra a rok jej uvedenia na trh. 
	Architektúry sú zoradené abecedne pod¾a vırobcu a následne pod¾a roku vydania.
	\item \textbf{Operácia}\newline
	Symbol pre príslušnú skalárnu aritmetickú operáciu na 64 bitovıch èíselnıch typoch s pohyblivou desatinnou èiarkou inštrukènıch sadách SSE a SSE4.
	\item \textbf{Odozva}\newline
	Poèet strojovıch cyklov potrebnıch na vykonanie inštrukcie.
	\item \textbf{Inverznı prietok}\newline
	Poèet strojovıch cyklov ktoré je nutné èaka kım je daná vıpoètová jednotka schopná zopakova inštrukciu. 
	V prípade operácií sèítania, odèítania a násobenia je tento poèet menší ako odozva. 
	To znamená, e aritmetické sèítaèky a násobièky sú schopné vïaka technike pipelining-u zaèa novı vıpoèet ešte pred dokonèením aktuálnehu vıpoètu.
\end{itemize}

\footnotetext{\label{footnote:round_divisor}Odozva je nadobúda menšie hodnoty ak je delite¾ celı.}
\begin{center}\label{tab:instr_speed}
 	\small
 	\begin{tabular}{l|cccc|cccc}
 		\toprule
 		& \multicolumn{4}{c|}{Odozva}  & \multicolumn{4}{c}{Inverznı prietok} \\
 		Architektúra (rok)
 		& $+$ & $-$ & $\cdot$ & $\div$ & $+$ & $-$ & $\cdot$ & $\div$ \\
 		\midrule
 		AMD Piledriver (2012)
 		& 5-6 & 5-6 & 5-6 & 9-27 & 0,5 & 0,5 & 0,5 & 5-10 	\\
 		%\hdashline		
 		Intel Penryn (2007)
 		& 3 & 3 & 5 & 6-21\footref{footnote:round_divisor} & 1 & 1 & 1 & 5-20\footref{footnote:round_divisor}	\\
 		Intel Nehalem (2008)
	 	& 3 & 3 & 5 & 7-22 & 1 & 1 & 1 & 7-22 	\\
 		Intel Sandy Bridge (2011)
 		& 3 & 3 & 5 & 10-22 & 1 & 1 & 1 & 10-22 	\\
 		Intel Haswell (2013)
 		& 3 & 3 & 5 & 10-20 & 1 & 1 & 0,5 & 8-14 	\\
 		Intel Skylake (2015)
	 	& 4 & 4 & 4 & 13-14 & 0,5 & 0,5 & 0,5 & 4 	\\
	 	\bottomrule
 	\end{tabular}
\end{center}
%\pozn{
%	 Všetky procesory majú identickú rıchlos sèítania a odèítania, preto budeme tieto dve operácie spoloène oznaèova symbolom $+$. Od tejto chvíle ak spomenieme operáciu sèítania tak tım budeme súèasne myslie aj operáciu odèítania. 
%}
Pod¾a tabuliek vidno, e operácie sèítania a odèítania sú rovnako rıchle èo sa pochopite¾ne dalo oèakáva. 
Tieto dve operácie preto budeme spoloène oznaèova symbolom $\pm$. 
Od tejto chvíle ak spomenieme operáciu sèítania tak tım budeme súèasne myslie aj operáciu odèítania. 
Ako vidie zïaleka najpomalšie je práve delenie.

Pre zaujímavos si môeme ukáza praktické vısledky z testovacej aplikácie. 
Merali sme operácie na dvoch 512 prvkovıch poliach, prièom aby sme dostali \uv{rozumne} dlhé èasy vıpoèty boli opakované 500000 krát. 
V tabu¾ke sú namiesto mikroarchitektúr uvedené konkrétne modely procesorov, prièom ich poradie zodpovedá poradiu z minulej tabu¾ky. 
Všetky údaju sú v milisekundách.

\begin{center}\label{real_op_speed}
	\begin{tabular}{lccc}
		\toprule
		Procesor
		& $\pm$ & $\cdot$ & $\div$  \\
		\midrule
		AMD FX-6300
		& 176 & 173 & 673  \\
		Intel Core 2 Duo E8200 
		& namerat & u & c. toroka  \\
		Intel Core i5 650
		& 198 & 224 & 1758  \\
		Intel Core i3 2350M
		& 233 & 231 & 2462  \\	
		Intel Core i5 4440
		& 120 & 119 & 1087  \\
		Intel Core i7 6700K
		& 99 & 99 & 257  \\
		\bottomrule
	\end{tabular}
\end{center}

V praxi vidno, e sèítavanie a násobenie môeme povaova za podobne rıchle operácie. 
Delenie bıva a desa násobne pomalšie. 
To je spôsobné ve¾mi vysokou hodnotou inverzného prietoku v prípade opakovane vykonávanom delení èo nastáva napríklad ak chceme vydeli dva vektory. 
V prípade našich algoritmov ale dochádza len k jednému deleniu na mnoho sèítaní a násobení. 
Z toho dôvodu môeme inverznı prietok v prípade delenia zanedba a v kontexte implementovanıch algoritmov delenie povaova pod¾a jeho odozvy za pribline \textbf{trojnásobne} pomalšie ako násobenie. 

\section{Teoretické zrıchlenie}
Dôvod, preèo je náš redukovanı algoritmus rıchlejší je práve fakt, e pri òom dochádza k znaène menšiemu poètu delení, ktoré je oproti ostatnım trom operáciám vırazne pomalšie. 
V ïalšej sekcii sy spoèítame jednotlivé operácie a vypoèítame teoretické zrıchlenie redukovaného algoritmu.

Spoèítajme poèet elementárnych matematickı operácií sèítania, násobenia a delenia pre oba algoritmy. 
To budeme poèíta tak, e si zadefinujeme \uv{procedúry} ktoré predstavujú jednotlivé èasti algoritmu. 
Potom z nich zostavíme pseudokód pre oba algoritmy.
Zaènime teda poèíta poèty operácií. 
Keïe všetky procesory pouité pri meraní obsahujú dve jednotky pre operácie s plávajúcou desatinnou èiarkou tak pri poèítaní budeme uvaova, e pri vırazoch s viacerımi operáciami vezmeme do úvahy len poloviènı poèet operácií. 
Najprv polome procedúry predstavujúce LU dekompozíciu spoloèné pre oba postupy.
\begin{itemize}
	\item
	Procedúra \textit{InicalizujLU} inicializuje hodnoty $r_0$, \dots, $r_{K-1}$ a $b$ z LU dekompozície \ref{eq:LU} pod¾a \ref{eq:deboorM} v prípade plného algoritmu, respektíve pod¾a \ref{eq:redM} v prípade redukovaného algoritmu.
	\item
	Procedúra \textit{VyriešLU} vypoèíta sústavu rovníc na základe hodnôt pravej strany poskytnutımi \textit{InicalizujLU}.    
\end{itemize}

\subsection{Poèty pre plnı algoritmus}

Poèty základnıch aritmetickıch a pamäovıch operácií pre vyššie uvedené procedúry môeme zhrnú do tabu¾ky, prièom uvaujeme poèty v našej ukákovej implementácii\footnote{Repozitár so zdrojovımi kódmi k aplikáciám mono nájs na adrese https://github.com/vildibald/VKDiplom-master}.
Riadky tabu¾ky predstavujú jednotlivé procedúry a 
ståpce udávajú poèet vykonanıch operácii, pre základné matematické operácie, kde $K$ je poèet neznámych. 
Podotıkam, e operáciu odèítania budeme uvaova ako sèítanie. 
Operácie MEM predstavuje kopírovanie vypoèítanıch derivácií do vıslednej matice uzlov.  
Ïalej musíme odlíši operácie vykonané na spojitıch a nespojitıch dátach pod¾a sekcie \ref{sec:kesovanie} o kešovaní. 
V prípade nespojitıch dát má znaènı vplyv na meranie práve prístup do nekešovanıch èastí pamäte. 
To èi matematické operácie v nasledujúcich procedúrach budú kešované alebo nie záleí od kontextu v akom sú volané.
Zatia¾ budeme predpoklada, e všetky operácie sú vykonávané na spojitıch dátach.
\begin{center}\label{lu_operations}
	\begin{tabular}{lcccc}
		\toprule
%		\diag{.1em}{4cm}{Procedúra}{Operácia}
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{InicalizujLU}
		& $K$ & $K$ & $0$ & $0$\\
		\textit{VyriešLU}
		& $4K$ & $4\textit{,}5K$ & $K$ & $K$\\
		\bottomrule
	\end{tabular}
\end{center}

Uvaujme procedúry predstavujúce implementáciu plného algoritmu:
\begin{itemize}
\item
Procedúra \textit{VypoèítajDx} vypoèíta parciálne derivácie $d^x$ pomocou procedúry \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor1}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^x$ pre jeden ståpec. 
Teda procedúra musí poèíta LU pre kadı ståpec, ktorıch je $J$. 
\item
Procedúra \textit{VypoèítajDxy} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúry \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor2}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^{xy}$ pre jeden ståpec. 
Procedúra musí poèíta LU pre prvı a poslednı ståpec.
\item
Procedúra \textit{VypoèítajDy} vypoèíta parciálne derivácie $d^y$ pomocou procedúry \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor3}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^y$ pre jeden riadok. 
Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$.
\item
Procedúra \textit{VypoèítajDyx} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúry \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor4}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^{xy}$ pre jeden riadok. 
Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$.
\item
Procedúra \textit{VypoèítajPlnı} vypoèíta na základe vstupnıch hodnôt pre de Boorovu interpoláciu \ref{eq:deboor_input} zavolaním procedúr \textit{VypoèítajDx}, \textit{VypoèítajDxy}, \textit{VypoèítajDy} a \textit{VypoèítajDyx}.    
\end{itemize}

%V podsekcii \ref{sec:kesovanie} sme odlišovali operácie vykonané na spojitıch vektoroch, t.j. operácie vykonané na ståpcoch matice uzlov a operácie vykonané na riadkoch, kde kadı prvok riadka je z iného vektora a teda aj z inej èasti pamäte pod¾a obrázka \ref{obr:jagged_array}. 
%Kešovanie riadkov znamená kešovanie celej matice uzlov, èo je v prípade ve¾kıch matíc nemoné. 
%Teda operácie na prvkov v riadkoch vo všeobecnosti nemôu by tak efektívne ako v prípade operácií na ståpcoch. 
%Pri našej implementácii, ako bolo spomenuté, na ukladanie uzlov a derivácií pouívame práve dátové štruktúry typu vektor vektorov, prièom derivácie $d^x$ sú poèítané po riadkoch (teda neefektívne)

Nech $I$ znaèí poèet uzlov na osi $x$ a $J$ znaèí poèet uzlov na osi $y$. 
Všetky poèty sú v tvare $a\cdot IJ + b\cdot I + c\cdot J + d$. 
Pre zjednodušenie budeme poèty, tam kde je koeficient $a$ nenulovı, uvádza v tvare $a\cdot IJ$. 
Keïe poèty rastú kvadraticky tak pre ve¾ké $I$ a $J$ bude odchılka zanedbate¾ná. 
Pre plnı algoritmus teda dostaneme tieto poèty

\begin{center}\label{full_operations_cached}	
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{VypoèítajDx}
		& $4IJ$ & $4\textit{,}5IJ$ & $IJ$ & $IJ$\\
		\textit{VypoèítajDxy}
		& $8I$ & $9I$ & $2I$ & $I$\\
		\textit{VypoèítajDy}
		& $4IJ$ & $4\textit{,}5IJ$ & $0$ & $IJ$\\
		\textit{VypoèítajDyx}
		& $4IJ$ & $4\textit{,}5IJ$ & $0$ & $IJ$\\
		\textbf{\textit{VypoèítajPlnı}}
		& $12IJ$ & $13\textit{,}5IJ$ & $3IJ$ & $3IJ$\\
		\bottomrule
	\end{tabular}
\end{center}
%Pre operácie nad nekešovanımi dátami dostávame  
%\begin{center}\label{full_operations_uncached}	
%	\begin{tabularx}{\textwidth}{l|XXXX}
%		\diag{.1em}{4cm}{Procedúra}{Operácia}
%		& $+$ & $\cdot$ & $\div$ & M \\
%		\hline
%		\textit{VypoèítajDx}
%		& $IJ$ & $IJ$ & $IJ$ & $IJ$\\
%		\textit{VypoèítajDxy}
%		& $2I$ & $7I$ & $2I$ & $m$\\
%		\textit{VypoèítajDy}
%		& $0$ & $0$ & $0$ & $0$\\
%		\textit{VypoèítajDyx}
%		& $0$ & $0$ & $0$ & $0$\\
%		\hdashline
%		\textbf{\textit{VypoèítajPlnı}}
%		& $IJ$ & $IJ$ & $IJ$ & $IJ$\\
%	\end{tabularx}
%\end{center}
% 
\subsection{Poèty pre redukovanı algoritmus}
Redukovanı spôsob na poèítanie derivácií vyuíva inı tvar trojdiagonálej sústavy rovníc. 
Zmeòme poèty operácií procedúr \textit{VyriešLU} a \textit{InicalizujLU}. 
Ïalej polome dve nové pomocné procedúry \textit{InicalizujZmiešLU}, ktorá inicializuje hodnoty $r_0$, \dots, $r_{K-1}$ a $b$ z LU dekompozície \ref{eq:LU} pre zmiešané derivácie $d^{xy}$ a k nej príslušnú \textit{VyriešZmiešLU}.

\begin{center}\label{red_lu_operations}
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{InicalizujLU}
		& $1\textit{,}5K$ & $K$ & $0$ & $0$\\
		\textit{VyriešLU}
		& $4\textit{,}5K$ & $4\textit{,}5K$ & $K$ & $K$\\
		\bottomrule
	\end{tabular}
\end{center}

V prípade poètov operácií v procedúrach pre zmiešané derivácie nepristupujeme k niektorı dátam spojito, navyše èítame dáta z nieko¾kıch vektorov naraz èo má malı negatívny vplyv na vıkon. 
Ten sa pri testovaní ukázal by malı v rozsahu 5\% a 20\% v závislosti od konkrétneho procesora. 
Aby sa nám to v následujúcej èasti nemılilo tak poèty uvedieme v samostatnıch tabu¾kách kde v prvej budú uvedené len poèty operácií na spojitıch dátach a následne na nespojitıch dátach. 
Pre spojité dáta máme

\begin{center}\label{cross_lu_operations_cached}
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{InicalizujZmiešLU}
		& $0$ & $0$ & $0$ & $0$\\
		\textit{VyriešZmiešLU}
		& $3K$ & $3\textit{,}5K$ & $K$ & $0$\\
		\bottomrule
	\end{tabular}
\end{center}
a pre operácie na nespojitıch dátach dostaneme 
\begin{center}\label{cross_lu_operations_uncached}
	\begin{tabular}{lcccc}
		\toprule
		Procedúra		
		& $+$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{InicalizujZmiešLU}
		& $16\textit{,}5K$ & $8\textit{,}5K$ & $0$ & $0$\\
		\textit{VyriešZmiešLU}
		& $16\textit{,}5K$ & $8\textit{,}K$ & $0$ & $K$\\
		\bottomrule
	\end{tabular}
\end{center}
Analogicky polome procedúry predstavujúce implementáciu redukovaného algoritmu:
\begin{itemize}
	\item
	Procedúra \textit{VypoèítajDxResty} vypoèíta zvyšné parciálne derivácie $d^x$ pod¾a \ref{eq:redr1}.
	\item
	Procedúra \textit{VypoèítajDx} vypoèíta parciálne derivácie $d^x$ pomocou procedúry \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red1}. 
	Jedno volanie \textit{VyriešLU} vypoèíta derivácie na párnych riadkoch $d^x$ pre jeden ståpec. 
	Teda procedúra musí poèíta LU pre kadı ståpec, ktorıch je $J$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajResty}.
	\item
	Procedúra \textit{VypoèítajDyResty} vypoèíta zvyšné parciálne derivácie $d^y$ pod¾a \ref{eq:redr2}.
	\item
	Procedúra \textit{VypoèítajDy} vypoèíta parciálne derivácie $d^y$ pomocou procedúry \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red2}. 
	Jedno volanie \textit{VyriešLU} vypoèíta derivácie na párnych ståpcoch $d^y$ pre jeden riadok. 
	Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajResty}.
	\item
	Procedúra \textit{VypoèítajDxy} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúry \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red3a} a \ref{eq:red3b}. 
	Jedno volanie \textit{VyriešLU} vypoèíta na párnych riadkoch(ståpcoch) derivácie $d^{xy}$ pre jeden ståpec(riadok). 
	Procedúra musí poèíta LU pre prvı a poslednı ståpec a pre prvı a poslednı riadok.
	\item
	Procedúra \textit{VypoèítajZmiešResty} vypoèíta zvyšné parciálne derivácie $d^{xy}$ pod¾a \ref{eq:redr4a}, \ref{eq:redr4b} a \ref{eq:redr4c}.
	\item
	Procedúra \textit{VypoèítajDyx} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúry \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red4}, prièom na ich inicializovanie do LU dekompozície pouijeme procedúru \textit{InicalizujZmiešLU}. 
	Jedno volanie \textit{VyriešLU} vypoèíta na párnych ståpcoch $d^{xy}$ pre jeden riadok. 
	Procedúra musí poèíta LU pre kadı párny riadok, ktorıch je $I$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajZmiešResty}.
	\item
	Procedúra \textit{VypoèítajRedukovanı} vypoèíta na základe vstupnıch hodnôt pre de Boorovu interpoláciu \ref{eq:deboor_input} postupnım vykonaním predchádzajúcich siedmich procedúr.    
\end{itemize}

Najprv si spoèítajme procedúry pre resty.

\begin{center}\label{rest_operations_cached}
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{VypoèítajDxResty}
		& $1\textit{,}5IJ$ & $IJ$ & $0$ & $0$\\
		\textit{VypoèítajDyResty}
		& $1\textit{,}5IJ$ & $IJ$ & $0$ & $0$\\
		\textit{VypoèítajZmiešResty}
		& $7IJ$ & $2\textit{,}5IJ$ & $0$ & $0$\\
		\bottomrule
	\end{tabular}
\end{center}

Opä pre zjednodušenie budeme poèty v tvare $a\cdot IJ + b\cdot I + c\cdot J + d$ zanedbáva na $a\cdot IJ$.
Ak hodnota $I$ znaèí poèet uzlov na osi $x$ a hodnota $J$ znaèí poèet uzlov na osi $x$ tak pre redukovanı algoritmus dostaneme následujúce poèty nad kešovanımi dátami  

\begin{center}\label{red_operations_cached}	
	%\begin{tabularx}{\textwidth}{l|cccc}	
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{VypoèítajDx}
		& $1\textit{,}5IJ$ & $1\textit{,}75IJ$ & $0$ & $0$\\
		\textit{VypoèítajDy}
		& $3IJ$ & $2\textit{,}75IJ$ & $0\textit{,}5IJ$ & $0\textit{,}5IJ$\\
		\textit{VypoèítajDxy}
		& $6I+8J$ & $7I+9J$ & $2I$ & $I$\\
		\textit{VypoèítajDyx}
		& $2\textit{,}875IJ$ & $1\textit{,}75IJ$ & $0\textit{,}25IJ$ & $0\textit{,}25IJ$\\	
		\textbf{\textit{VypoèítajRedukovanı}}
		& $7\textit{,}375IJ$ & $6\textit{,}25IJ$ & $0\textit{,}75IJ$ & $0\textit{,}75IJ$\\
		\bottomrule
	\end{tabular}
\end{center}
V prípade \textit{VypoèítajDyx} ešte musíme zapoèíta operácie nad nespojitımi dátami
\begin{center}\label{red_operations_uncached}
	\begin{tabular}{lcccc}
		\toprule
		Procedúra
		& $\pm$ & $\cdot$ & $\div$ & M \\
		\midrule
		\textit{VypoèítajDyx}
		& $4\textit{,}175IJ$ & $2\textit{,}125IJ$ & $0$ & $0$\\
		\textbf{\textit{VypoèítajRedukovanı}}
		& $2\textit{,}675IJ$ & $3\textit{,}215IJ$ & $0\textit{,}5IJ$ & $0\textit{,}5IJ$\\
		\bottomrule
	\end{tabular}
\end{center}

\subsection{Pamäové nároky}

Redukovanı algoritmus by nemal by lepší len v poète aritmetickıch operácií. 
Uvaujme maticu uzlov ve¾kosti $I$ a $J$.
Potrebujeme si pamäta $I\cdot J$ funkènıch hodnôt v uzloch, derivácií pod¾a $x$, $y$ a zmiešanıch derivácií. 
Samotné uzly si pamäta nemusíme lebo uvaujeme len uniformné splajny. 
Teda staèí si nám uloi iba uzly $u_0$, $u_{I-1}$, $v_0$, $v_{J-1}$. 
Zvyšné uzly si vieme vypoèíta vzorcom $u_i =u_0 + |u_{I-1} - u_0|\cdot \frac{i}{I}$ pre ¾ubovo¾né $i$ z $\{1, \dots, I-2\}$, respektíve $v_j =v_0 + |v_{J-1} - v_0|\cdot \frac{j}{J}$ pre ¾ubovo¾né $j$ z $\{1, \dots, J-2\}$. Potrebujeme si teda pamäta aspoò $4\cdot I\cdot J + 4$ èísel pre funkèné hodnoty uzlov.

Poèítanie LU dekompozície všeobecne potrebuje pä vektorov, kde tri predstavujú trojdiagonálu, jeden pravú stranu a poslednı pre vısledok.
Ten môeme zapisova priamo do vektora pravej strany ak ju nepotrebujeme zachova. 
 
\begin{algorithm}
	\caption{Všeobecná LU dekompozícia
	\label{alg:SolveGeneralLU}}
	\begin{algorithmic}[1]
	\Procedure{VyriešLU}{}
	\State \textbf{vstup:}	
	\State
	$l[0..n-2]$ spodná diagonála
	\State
	$m[0..n-1]$ hlavná diagonála
	\State
	$u[0..n-2]$ horná diagonála, po skonèení sa nezachová
	\State
	$r[0..n-1]$ pravá strana
	\State \textbf{vıstup:} $r[0..n-1]$ pravá strana obsahujúca vısledok 
	\State
	
%	$p \gets [0..n-1]$
	\State $u[0]\gets \sfrac{u[0]}{m[0]}$
	\State $r[0]\gets \sfrac{r[0]}{m[0]}$
	\For{$i$ \textbf{od} $1$ \textbf{a} $n-1$} 
		\State $q \gets \sfrac{1}{m[i]-l[i]\cdot u[i-1]}$
		\State $u[i] \gets q\cdot u[i]$
		\State $r[i] \gets q\cdot (r[i] - l[i]\cdot r[i-1])$
	\EndFor
	\For{$i$ \textbf{od} $n-2$ \textbf{a} $0$} 	
		\State $r[i] \gets r[i] - u[i]\cdot r[i+1]$
	\EndFor
	\EndProcedure

	\end{algorithmic}
\end{algorithm}

V prípade poèítania derivácií je sústava rovníc v špeciálnom tvare pod¾a \ref{eq:deboorM} pre plnı alebo \ref{eq:redM} pre redukovanı algoritmus.
V oboch prípadoch všetky èísla na hornej aj spodnej diagonále majú hodnotu $1$. 
Na hlavnej diagonále sú to hodnoty $4$ pri plnom algoritme a v prípade redukovaného postupu sú to hodnoty $-14$. 
Poslednı prvok diagonály tie môe obsahova hodnotu $-15$ ak poèet rovníc je párny. 
Teda pri implementácii si nemusíme pamäta vektory, staèí nám zapamäta si iba štyri hodnoty. 
Upravenı algoritmus, ktorı rieši LU dekompozíciu pre plnı a redukovanı algoritmus vyzerá takto. 

\begin{algorithm}
	\caption{Špeciálna LU dekompozícia
		\label{alg:SolveLU}}
	\begin{algorithmic}[1]
		\Procedure{VyriešLU}{}
		\State \textbf{vstup:}	
		\State
		\State
		$m$ hodnota prvkov hlavnej diagonály
		\State
		$m_l$ hodnota posledného prvku hlavnej diagonály
		\State
		$r[0..n-1]$ pravá strana
		\State \textbf{vıstup:} $r[0..n-1]$ pravá strana obsahujúca vısledok 
		\State
				
		\State$u \gets [0..n-2]$
		\Comment Pomocnı vektor nahradzujúci hornú diagonálu
		\State $q \gets \sfrac{1}{m}$
		\State $u[0]\gets q$
		\State $r[0]\gets q \cdot r[0]$
		\For{$i$ \textbf{od} $1$ \textbf{a} $n-2$} 
		\State $q \gets \sfrac{1}{m - u[i-1]}$
		\State $u[i] \gets q$
		\State $r[i] \gets q\cdot (r[i] - r[i-1])$
		\EndFor
		\State $q \gets \sfrac{1}{m_l - u[n-1]}$
		\State $u[i] \gets q$
		\State $r[i] \gets q\cdot (r[n-1] - r[n-2])$
		\For{$i$ \textbf{od} $n-2$ \textbf{a} $0$} 	
		\State $r[i] \gets r[i] - u[i]\cdot r[i+1]$
		\EndFor
		\EndProcedure	
	\end{algorithmic}
\end{algorithm}

Pri pouitá tejto priestorovo optimalizovanej varianty vıpoètu LU dekompozície potrebujeme na vypoèítanie $I\cdot J$ uzlov práve $I\cdot J + 2I + 2J$ pamäte.

\subsection{Zhrnutie}
Teraz máme spoèítané jednotlivé matematické a pamäové operácie.

V záujme preh¾adnosti v rámci tejto podsekcie zaveïme tieto oznaèenia 
\begin{oznac} \label{oznac:spoj_nespoj_dat_strukt}
Oznaème dve triedy dátovıch štruktúr symbolmi:
\begin{itemize}
	\item
	$\rightY$ oznaèuje spojité dátové štruktúry ako napríklad vektory,
	\item 
	$\righttherefore$  oznaèuje nespojité dátové štruktúry ako napríklad spájané zoznamy alebo vektory referencií na konkrétne dáta .
\end{itemize} 
\end{oznac}
Nech $t_\text{operácia}^\text{dáta}$ udáva dobu trvania nejakej operácie na nejakıch dátach.
Napríklad $t_+^\text{spojité}$ udáva èas sèítania dvoch rovnako ve¾kıch spojitıch kešovanıch vektorov.
Na zaèiatku sekcie sme zvolili predpoklad, e pri èíselnıch typoch s pohyblivou èiarkou sú operácie sèítania (odèítania) a násobenia rovnako rıchle. 
Na všetkıch testovanıch procesoroch je totone rıchla aj pamäová operácia kopírovania pri spojitıch dátach. 
Teda $t_+ = t_\times = t_{\text{MEM}_\text{c}}$.
Polome si teraz pomery udávajúce pomery dôb trvania jednotlivıch operácií.
\begin{itemize}
\item
$\gamma = \frac{t_{\div}^\rightY}{t_{\plus}^\rightY}$
\item 
$\eta = \frac{t_{\textit{M}}^\righttherefore}{t_{\textit{M}}^\rightY}$
\item 
$\iota = \frac{t_{\plus}^\righttherefore}{t_{\plus}^\rightY}$
%\item 
%$\lambda = \frac{t_{\div}^\righttherefore}{t_{\plus}^\righttherefore}$
\end{itemize}
	
%Nech $c_\text{operácia}^{\text{dáta}}$ znaèí celkovú cenu operácie v algoritme.
%Pod¾a tabuliek poètov z predchádzajúcich podsekcií a práve zadefinovanıch pomerov dostaneme následovné ceny kde $I$ a $J$ sú rozmery matice uzlov.
%Pre plnı al
%\begin{itemize}
%	\item
%	$c_\plus^{\leftY} = 11IJ$
%	\item 
%	$c_\plus^{\lefttherefore} = IJ$
%	\item
%	$c_\^{\leftY} = 11IJ$
%	\item 
%	$c_\plus^{\lefttherefore} = IJ$
%\end{itemize}
	
Celková cena algoritmu je teda súèet poètu všetkıch operácií z tabuliek \ref{full_operations_cached} pre plnı algoritmus, respektíve \ref{red_operations_cached} a \ref{red_operations_uncached} pre redukovanı algoritmus z predchádzajúcich podsekcií. 
Poèty operácií delenia na kešovanıch dátach vynásobime $\gamma$, poèty nekešovanıch pamäovıch operácií vynásobime $\eta$, poèty operácií sèítania a násobenia na nespojitıch dátach vynásobime $\iota$.
%a nakoniec poèty operácií delenia na nekešovanıch dátach vynásobime $\lambda \iota$ (pretoe $\lambda$ udáva pomer delenia a sèítania na nekešovanıch dátach a to ešte treba vynásobi $\iota$).

Pre plnı algoritmus teda dostávame
\begin{equation} \label{sum_full_operations}
25\textit{,}5IJ+2\gamma IJ+\eta IJ+2\iota IJ+\lambda \iota IJ\text{,}
\end{equation}
a pre redukovanı máme
\begin{equation} \label{sum_red_operations}
14\textit{,}375IJ+0\textit{,}75\gamma IJ+0\textit{,}5\eta IJ+5\textit{,}84\iota IJ+0\textit{,}5\lambda \iota IJ\text{.}
\end{equation}

Ak chceme urèi zrıchlenie redukovaného algoritmu staèí vydeli \ref{sum_full_operations} a \ref{sum_red_operations} èím dostaneme
	
\begin{equation} \label{full_red_ratio}
\frac{
	25\textit{,}5IJ+2\gamma IJ+\eta IJ+2\iota IJ+\lambda \iota IJ
}{
14\textit{,}375IJ+0\textit{,}75\gamma IJ+0\textit{,}5\eta IJ+5\textit{,}84\iota IJ+0\textit{,}5\lambda \iota IJ\text{.}
}
\end{equation}

\begin{df}
	Vıraz \ref{full_red_ratio} nazveme \pojem{pomer rıchlostí}. 
\end{df}
\pr{ \label{ratio10}
	Ak budeme predpoklada $\gamma = 3$, to jest operácia delenia je trojnásobne pomalšia ako operácia sèítania, ïalej $\eta = 4$ (pod¾a obrázka \ref{img:cacheSpeed}), $\iota = 1\textit{,},1$ a $\lambda = 1$ a budeme uvaova maticu uzlov s poètom $I\times J = 1000\times1000$ tak pomer rıchlostí bude $1{,}18$, teda plnı algoritmus je $1{,}18$ krát pomalší ako redukovanı.	
}

\section{Zrıchlenie v praxi}

V kapitole \nameref{spdup} sme urèili teoretické zrıchlenie poèítania uzlov, dosiahnute¾né zredukovaním ve¾kosti trojdiagonálnych sústav. 
V tejto èasti si ukáeme reálne vısledky dosiahnuté v ukákovej implementácii. 

Ako bolo spomenuté, testovacia aplikácia bola implementovaná v jazyku \cpp. 
Program obsahuje testy pre sekvenèné aj paralelné poèítanie derivácií pre oba predmetné algoritmy.
Pouitı prekladaè bol Intel \cpp\ Compiler v 64 bitovej verzii nastavenı na generovanie agresívne optimalizovaného binárneho kódu (-O2), prièom paralelnı kód bol implementovanı pomocou rozhrania OpenMP.    

Testy boli vykonané na šiestich rôznych poèítaèovıch zostavách, všetky so systémom Windows 7 a 10. 
Testovacie stroje obsahujú rozlièné multivláknové procesory od starého Penryn z roku 2007 a po najmodernejší Skylake z roku 2015 so vzájomne odlišnımi architektúrami a hlavne spôsobmi vykonávania paralelizovanıch procesov. 
%Procesory oznaèené $^\text{SMT}$ sú vybavené nejakou implemetáciou simultánneho multithreadingu.

Ståpec 1 obsahuje modely procesorov zoradenıch pod¾a mikroarchitektúry ako v tabu¾ke \ref{tab:instr_speed}.
Ved¾a názvu modela CPU sa nachádza údaj tvaru $n$C/$m$T, kde $n$ je poèet fyzickıch jadier procesora a $m$ poèet logickıch jadier. 
V prípade $m > n$ je procesor vybavenı urèitou formou SMT. 
Ståpce 2 a 3 predstavujú èasy behov sekvenènıch implementácií plného a redukovaného algoritmu v prípade krivkovıch splajnov. 
Ståpce 4 a 5 predstavujú èasy behov sériovej verzie pre povrchové splajnov.
Ostávajúce ståpce analogicky znázoròujú èasy a pomer paralelnıch verzií. Všetky uvedené èasové údaje sú v milisekundách.  

\begin{center}\label{real_speedup}
	\begin{tabular}{lcccccc}
		\toprule
		& \multicolumn{2}{c}{Krivka} & \multicolumn{2}{c}{Sériovo} & \multicolumn{2}{c}{Paralelne}  \\
		Procesor
		& Plnı & Reduk. & Plnı & Reduk. & Plnı & Reduk.  \\
		\midrule
		FX-6300 \tiny{3C/6T}
		&  &  &  &  &  &\\
		C2D E8200 \tiny{2C/2T}
		&  &  &  &  &  &\\
		Ci5 650 \tiny{2C/4T}
		&  &  &  &  &  &\\
		Ci3 2350M \tiny{2C/4T}
		& 66 & 53 & 153 & 131 & 82 & 81 \\	
		Ci5 4440 \tiny{4C/4T}
		&  &  &  &  &  &\\
		Ci7 6700K \tiny{4C/8T}
		& 29 & 25 & 61 & 52 & 25 & 26 \\
		\bottomrule
	\end{tabular}
\end{center}
  
%\begin{center}\label{real_speedup}
%	\begin{tabular}{l?{2}ccc|ccc|ccr}
%		& \multicolumn{3}{c|}{Operácia} & \multicolumn{3}{c|}{Sekvenène} & \multicolumn{3}{c}{Paralelne}  \\
%		CPU
%		& $+$ & $\cdot$ & $/$ & Plnı & Red & F : R & Plnı & Red & F : R  \\
%		\hline
%		Core i5 4440
%		& 121 & 121 & 1087 & 128 & 101 & 1,27 & 55 & 56 & 0.98  \\
%		Core i3 2350M
%		& 325 & 297 & 3151 & 252 & 202 & 1,25 & 142 & 145 & 0,98  \\
%		FX-6300
%		& 133 & 136 & 529 & 180 & 146 & 1,23 & 78 & 79 & 0,99  \\
%	\end{tabular}
%\end{center}

%Na kadom z troch testovacích strojov sú rıchlosti sèítania a násobenia 64 bitovıch èísel s plávajúcou desatinnou èiarkou totoné. V prípade násobenia, respektíve sèítania a delenia vychádza pomer na procesoroch Intel Core i5 a i3 pribline 9.
Sériová verzia redukovaného algoritmu je o pribline 18\% rıchlejšia ako pôvodnı de Boorov postup èo súhlasí s odhadnutım zlepšením na konci kapitoly \nameref{spdup} v príklade \ref{ratio10}. 
%Tam nám vyšlo 19\% zrıchlenie, kde zbytok prisudzujem vplyvu pamäovıch operácií, ktoré sme vtedy nebrali do úvahy.

%V prípade procesora AMD FX si môeme všimnú anomáliu, kde novı algoritmus je vırazne rıchlejší ne by mal by pod¾a dosiahnutého pomeru rıchlosti násobenia a delenia. 
%Moja terajšia hypotéza k tomuto javu je zaloená na pozorovaní, e AMD FX procesory majú vırazne pomalší pamäovı subsystém vèítane systému rıchlych vyrovnávacích pamätí\cite{cacheAmd} (tzv. \textit{cache}).
%Pamäové operácie sú teda na AMD FX procesore vırazne drahšie ako na Intel Core. 
%Redukovanı algoritmus má menšie priestorové nároky èo znamená menej %pouitıch pamäovıch operácií. 
%Teda na procesore AMD FX má síce zníenie poètu delení menší vplyv na efektivitu redukovaného algoritmu, ale to mohlo by \uv{vyváené} práve zníením poètu, na tomto CPU pomalıch, pamäovıch operácií.

Môeme všimnú malé škálovanie vıkonu paralelizovaného algoritmu najmä v prípade procesorov obsahujúcich nejakú formu SMT kde je redukovanı algoritmus dokonca o nieèo pomalší ako plnı. 
Prvou zmıš¾anou príèinou môe by fakt, e v plnom algoritme všetky parciálne derivácie pod¾a nejakej premennej vypoèítame trojdiagonálnymi sústavami naraz v jednom cykle. 
V redukovanom ale cez trojdiagonálne sústavy vyrátame len polovicu derivácií, prièom zvyšok dopoèítame práve restami. 
Toto rozdelenie vıpoètu na dve subprocedúry môe hypoteticky implikova vysokú réiu plánovaèa vlákien (tzv. \pojem{thread scheduler}) OpenMP alebo operaèného systému. 
V implementácií sa nám síce podarilo spoji vıpoèet restov spolu s LU dekompozíciou do jedného kroku v prípade derivácií pod¾a premennıch $x$ a $y$. 
Teda resty môeme poèíta súèasne s deriváciami poèítanımi cez LU.
Táto optimalizácia však momentálne nie je moná pri zmiešanıch deriváciách. 
Síce máme rozpracované zefektívnenie vıpoètu zmiešanıch restov, ktoré sa nám ale ešte nepodarilo do práce dokonèi. 

V prípade SMT procesorov sa dá pomalos, aj keï to nemáme overené, vysvetli ešte superskalárnosou pod¾a podsekcie \ref{sec:instrukcny_paralelizmus}. 
Väèšina modernıch mikroarchitektúr má jadrá vybavené práve dvomi matematickımi jednotkami pre operácie s plávajúcou desatinnou èiarkou (oznaèujú sa skratkou FPU). 
V tomto prípade SMT môe teoreticky kadú jednotku prideli inému vláknu. 
Pri redukovanom algoritme ale máme ve¾a operácií v tvare $a_0a_1\circ \dots\circ a_n$, kde $\circ \in \{+, \cdot\}$ kde optimalizujúci prekladaè môe takıto vıpoèet rozloi do viacerıch strojovıch inštrukcií. 
V tomto prípade dôjde k vyuitiu oboch FPU jadra v rámci jediného vlákna ale napriek tomu SMT na toto jadro priradí aj druhé vlákno ktoré poèíta práve na FPU. 
Dôjde tak k zbytoènej réii plánovaèa vlákien èi u na úrovni OS alebo inštrukèného plánovaèa samotného procesora, èo spôsobí pokles vıkonu. 

Ak je táto hypotéza korektná tak by bolo potrebné upravi resty, najmä pri zmiešanıch deriváciách, aby sa ich vıpoèet dal vykona paralelne v jednom kroku spolu s LU dekompozíciou   
  
%Táto príèina sa po prepracovaní implementácie ukázala bezpredmetná.  
%\footnote{Túto hypotézu vplyvu cache je potrebné ešte podrobnejšie otestova, k èomu sa dostanem pravdepodobne v priebehu februára.} 

\chapter{Implementácia a uívate¾ská príruèka} \label{chapt:impl}
Jednım z naším cie¾om je vytvorenie aplikácií na vizuálne a vıkonnostné porovnávanie splajnov, ktorıch uzly sú poèítané De Boorovim a našim redukovanım algoritmom. 
Pôvodne sme vizuálnu èas implementovali v Microsoft Silverlight, èo je bezplatnı nástroj na tvorbu webovıch aplikácií spustite¾nıch priamo vo webovom prehliadaèi. 
Samotnı vıvoj aplikácii môe prebieha v ¾ubovo¾nom programovacom jazyku beiacom pod virtuálnym strojom Common Language Runtime. 
V našom prípade sme siahli po jazyku C\#.

\begin{center}
	\includegraphics[scale=0.2]{silverlight.jpg}
\end{center}

Silverlight je kompatibilnı s väèšinou modernıch webovıch prehliadaèov a operaènıch systémov vèítane Microsoft Windows, Apple OS X a vïaka technológii Moonlight -- open-source implementácii Silverlight-u aj na väèšine Linuxovıch distribúcií.
Framework je moné poui aj na vıvoj off-line aplikácií v operaènıch systémoch Windows Phone, Windows 8 a Windows RT. 

\pozn{
	Naša aplikácia pouíva technológie, ktoré nie sú s Moonlight kompatibilné. 
	V súèasnej dobe teda podporujeme iba MS Windows a Apple OS X.
	Prípadná portácia na GNU/Linux by musela by vo forme off-line desktopovej aplikácie.
}

\obrazok{apka_spl.png}{0.307}{Ukáka z aplikácie.}

Pretoe CLR znemoòuje korektne porovnáva procesorovı èas a pamäové nároky implementovanıch algoritmov, rozhodli sme sa vıkonnostnı tester oddeli do samostatnej aplikácie implementovanej v natívnom jazyku, konkrétne v jazyku \cpp. 

\obrazok{bench.png}{0.407}{Vıkonnostnı tester.}

\subsection{Vizualizácia}
V tejto kapitole si ukáeme struènı návod na pouívanie a testovanie implementovanıch aplikácií. 
Zaènime aplikáciou na grafickú vizualizáciu.
\obrazok{apka.png}{0.307}{Aplikácia po spustení.}

Okno aplikácie sa skladá z troch hlavnıch èastí, ktoré si trocha netradiène prejdeme zdola nahor.
%\begin{figure}%[!htb]
%	
%	 \centering
%		\includegraphics[scale=0.4]{apka_spod.png}
%	\par
%	\centering{\parbox{13cm}{\sl \caption{Panel zadávania splajnu.}}
%\end{figure}
\obrazok{apka_spod.png}{0.4}{Panel zadávania splajnu.\label{apka_spod}} 
Na obrázku \ref{apka_spod} vidíme panel, pomocou ktorého môeme na ¾ubovo¾nom intervale a s ¾ubovo¾nım poètom uzlov (v rozumnıch medziach) interpolova zapísanú funkciu dvoch premennıch $x$ a $y$.
Popíšme si jednotlivé ovládacie prvky. 
Textové polia oznaèené \textit{U min}, \textit{U max} a \textit{U knots} (\textit{V min}, \textit{V max} a \textit{V knots}) znaèia interval a poèty uzlov na osi $x$ (osi $y$).
Do spodného textového políèka oznaèené \textit{Expression} môeme napísa takmer ¾ubovo¾nú matematickú funkciu premennıch $x$ a $y$ ktorú si eláme vykresli. 
Vysúvate¾nı zoznam oznaèenı \textit{Function type} umoòuje zvoli typ interpolácie. 
Na vıber máme ponúknuté tri monosti akım spôsobom si eláme interpretova matematickı vıraz v políèku \textit{Expression}.
\begin{itemize}
	\item
	\textit{Direct function} vypoèíta funkèné hodnoty potrebné pre grafickú vizualizáciu priamo z funkcie.
	\item 
	\textit{Bicubic} vypoèíta z funkcie iba funkèné hodnoty v uzloch.
	Zvyšné potrebné body sú získané interpolaènım bikubickım splajnom. 
	\item 
	\textit{Biquartic} funguje analogicky ako predchádzajúca poloka. 
	Pouije sa ale bikvartickı splajn.
\end{itemize}
Vysúvate¾nı zoznam oznaèenı \textit{Knots generator} nám, v prípade vıberu vykreslenia funkcie splajnom, umoòuje zvoli plnı (\textit{De Boor}) alebo redukovanı (\textit{Reduced de Boor}) algoritmus.
Tlaèítko \textit{Subtract} umoní vykresli rozdiel medzi aktuálne zadanımi hodnotami a nejakou u vykreslenou funkciou. 
Pomocou posuvníka oznaèenı \textit{Auto color} môeme namiesto automaticky vybranej farby vykresli novú plochu vlastnou farbou.
Nakoniec v pravej èasti okna sa nachádzajú tlaèidlá \textit{Clear} a \textit{Draw}, prièom prvé odstráni všetky vykreslené funkcie a druhé nám vypoèíta a zobrazí funkciu pod¾a aktuálne zadanıch hodnôt. 


\obrazok{apka_stred.png}{0.4}{Hlavné zobrazovacie okná.\label{apka_stred}} 
Na obrázku \ref{apka_stred} vidíme dominantnú èas aplikácie a síce zobrazovanie funkciovıch plôch. 
Obrazovka je rozdelená na tri èasti, kde v najväèšia èast implicitne zobrazuje interpretovanú funkciu a zvyšné dve zobrazujú prvú, respektíve druhú zmiešanú deriváciu funkcie.
V ¾avej èasti okna môeme nájs posuvník na škálovanie osi $z$. 
Na spodnej a pravej strane hlavnej èasti okna sú tlaèidlá reprezentované modrou horizontálnou, respektíve zelenou vertikálnou šípkou. Pri ich draní myšou je moné rotova obrazom v danej osi.


\obrazok{apka_vrch.png}{0.4}{Lišta nástrojov.\label{apka_vrch}}
Poloka \textit{Settings} umonuje prispôsobi grafické vykres¾ovanie splajnov. 
Tieto nastavenia je vhodné upravi najmä pri starších poèítaèoch na dosiahnutie optimálnej plynulosti vykres¾ovania.
V strednej èasti panela máme k dispozícii vysúvate¾nı zoznam vykres¾ovanıch plôch, ktorım ich môeme zvırazòova. 
V pravej èasti nájdeme tri tlaèidlá, ktoré vycentrujú zobrazovanie splajnu, 
prípadne jeho prvej alebo druhej zmiešanej derivácie.

\subsection{Vıkonnostnı tester}
Teraz si popíšme druhú implementovanú aplikáciu zameranú nie na vykres¾ovanie, ale na ukáku èi skutoène je redukovanı algoritmus rıchlejší.  
\obrazok{bench.png}{0.407}{Vıkonnostnı tester.\label{bench}}
\obrazok{bench_surface.png}{0.407}{Zadanie údajov pre testovanie.\label{bench_surface}}
\obrazok{bench_surface_results.png}{0.407}{Vısledky testu.\label{bench_surface_results}}
Na obrázku \ref{bench} môeme vidie úvodné okno aplikácie, ktoré obsahuje sedem poloiek. 
Ich vıznam si teraz vyjasníme.
 \begin{itemize}
 	\item[1.]
 	\textit{Multiplication  vs division benchmark} spustí nieko¾ko variant testovania pomerov rıchlosti operácií sèítania, násobenia a delenia.
 	\item[2.] 
 	\textit{Spline curve benchmark} pomerá èasy vıpoètov derivácií pre krivkovı splajn interpolujúci preddefinovanú funkciu plnım a redukovanım algoritmom. 
 	Pred spustením aplikácie vyaduje postupne zadanie dvoj údajov. 
 	Prvı udáva poèet opakovaní testu pre kadı algoritmus. 
 	Vıslednı pomer vznikne vydelením aritmetickıch priemerov nameranıch èasov pre kadı algoritmus. 
 	Èím je zadané èíslo väèšie, tım je meranie menej náchylné na odchılky. Odporúèa sa zada dvojcifernú hodnotu a potvrdi klávesou \textbf{Enter}. 
 	Druhé zadané èíslo znamená poèet uzlov splajnu. 
 	Odporúèa sa zada rádovo $10^5$ a $10^6$ uzlov.
 	Menší poèet dokáe väèšina modernıch poèítaèov vypoèíta príliš rıchlo aby ten èas dokázala aplikácia rozumne zmera.  
 	\item[3.]
 	\textit{Spline surface benchmark} analogicky ako predchádzajúci test testuje pomer èasov vıpoètu plného a redukovaného algoritmu pre plochy. 
 	Druhı zadanı údaj tentoraz znamená poèet uzlov pre jeden rozmer.
 	Celkovı poèet uzlov je teda štvorec zadanej hodnoty. 
 	Pre väèšinu poèítaèov sa odporúèa zada rádovo $10^2$ a $10^3$ uzlov.
 	\item[4.]
	\textit{Spline surface benchmark (in parallel)} paralelná verzia testu pre plochy vyuívajúca na vıpoèet jednej matice uzlov všetky dostupné logické procesory.
 	\item[B.]
 	\textit{Disable/enable buffering} prepne medzi naivnou a optimalizovanou variantou algoritmu pre poèítanie LU dekompozície v testoch 2 a 3. 
 	Test 4 toto nastavenie neovplyvòuje z dôvodu znaènıch pamäovıch nárokov naivnej verzie LU dekompozície.
 	\item[Q.]
 	\textit{End program} ako názov napovedá, pri stlaèení tlaèidla \textbf{Q} dôjde k vypnutiu aplikácie.
 \end{itemize}


\chapter*{Záver}

Podarilo sa nám teda pomerne vırazne urıchli vıpoèet derivácií splajnov v ich uzloch a tie zmenši pamäové nároky algoritmu.
Samozrejme stále existujú oblasti v ktorıch by sa dal zlepši. 
Prioritou teraz ostáva jednak zovšeobecni redukovanı algoritmus aj pre neuniformné splajny a upravi zmiešané zbytkové derivácie aby sme mohli zefektívni paralelizáciu. 
Tá má momentálne prínos najmä v poloviènıch pamäovıch nárokoch. 

%
%\bibliography{dp} %berie sa z dp.bib

%\renewcommand{\bibname}{Zoznam pou?itej literat?ry}
\begin{thebibliography}{9}
\bibitem{splines}  David Salomon, Curves and Surfaces for Computer Graphics, Springer, 2006
\bibitem{szabominotorok}  I. Szabó, L. Miòo, C. Török, Biquartic polynomials in bicubicspline construction, PF UPJŠ, 2014 
\bibitem{lukasRigorozka}  L. Miòo, Parametrické modelovanie dát komplexnej štruktúry, PF UPJŠ, 2014
\bibitem{deboor}  C. de Boor, Bicubic spline interpolation, Journal of Mathematics and Physics, 41(3),1962, 212-218.
\bibitem{csharp}  J. Albahari, B.Albahari, C\# 5.0 in a Nutshell, O'Reilly, 2012
\bibitem{her_nat}	 E. S\"{u}li, D. Mayers, An Introduction to Numerical Analysis, Cambridge University Press, 2003, ISBN 0 521 00794 1
%\bibitem{app}  https://github.com/vildibald/VKDiplom-master, repozitár so zdrojovımi kódmi k aplikáciám.
\bibitem{cacheIntel} http://www.anandtech.com/show/9483/intel-skylake-review-6700k-6600k-ddr4-ddr3-ipc-6th-generation/9
\bibitem{intelOpt} http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf
\bibitem{instrTables} http://www.agner.org/optimize/instruction\_tables.pdf
\bibitem{pipelining} http://www.lighterra.com/papers/modernmicroprocessors/
\bibitem{cacheAmd} http://techreport.com/review/23750/amd-fx-8350-processor-reviewed/3
\end{thebibliography}
%
\end{document}