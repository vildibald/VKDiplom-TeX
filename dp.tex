% !TEX encoding = System

%%\documentclass[thesismargins, thesislinespacing, twoside, draft, upjsfrontpage]{rnthesis}
\documentclass{rnthesis}
\usepackage[slovak]{babel}
\usepackage[T1]{fontenc}
\usepackage[cp1250]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{rnt-pic}
\usepackage{rnt-thm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}
\usepackage{hyphenat}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{array}
\usepackage{nameref}
\usepackage{array}
\usepackage{makecell}
\usepackage{arydshln}
\usepackage{tabularx}
\usepackage{bm}
\usepackage{MnSymbol}
\usepackage{scrextend}
\usepackage{booktabs}
\usepackage{xfrac}
\usepackage{mathtools}
\usepackage{color,colortbl}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%\usepackage{fontspec}
% cierne linky bez ohranicenia
\usepackage[bookmarksnumbered,colorlinks=true, allcolors=black]{hyperref}
% linky s ohranicenim
%\usepackage[bookmarksnumbered,colorlinks=false, allcolors=black]{hyperref}

\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage{tikz}


\makeatletter
\renewcommand{\ALG@name}{Algoritmus}
\renewcommand{\listalgorithmname}{Zoznam algoritmov}

\renewcommand\algorithmicwhile{\textbf{pokia¾}}
\renewcommand\algorithmicdo{\textbf{}}
\renewcommand\algorithmicend{\textbf{koiec}}
\renewcommand\algorithmicif{\textbf{ak}}
\renewcommand\algorithmicthen{\textbf{potom}}
\renewcommand\algorithmicelse{\textbf{inak}}
\renewcommand\algorithmicfor{\textbf{pre}}
\renewcommand\algorithmicprocedure{\textbf{procedúra}}

\makeatother

\newcommand\diag[4]{%
	\multicolumn{1}{p{#2}|}{\hskip-\tabcolsep
		$\vcenter{\begin{tikzpicture}[baseline=0,anchor=south west,inner sep=#1]
			\path[use as bounding box] (0,0) rectangle (#2+2\tabcolsep,\baselineskip);
			\node[minimum width={#2+2\tabcolsep-\pgflinewidth},
			minimum  height=\baselineskip+\extrarowheight-\pgflinewidth] (box) {};
			\draw[line cap=round] (box.north west) -- (box.south east);
			\node[anchor=south west] at (box.south west) {#3};
			\node[anchor=north east] at (box.north east) {#4};
			\end{tikzpicture}}$\hskip-\tabcolsep}}


\hyphenation{funk-cií}

\RequirePackage{ifpdf}

\ifpdf
\RequirePackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{eps}{*}{}
\else
\RequirePackage[xdvi]{graphicx}
\fi

\lstset{language=[Sharp]C,
showspaces=false,
showtabs=false,
breaklines=true,
%basicstyle=\tiny,
basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
numbersep=5pt,
tabsize=2,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{commentsColor},
keywordstyle=\color{keywordsColor}\bfseries,
stringstyle=\color{stringsColor},
%basicstyle=\ttfamily
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morekeywords={abstract, event, new, struct,
as, explicit, null, switch,
base, extern, object, this,
bool, false, operator, throw,
break, finally, out, true,
byte, fixed, override, try,
case, float, params, typeof,
catch, for, private, uint,
char, foreach, protected, ulong,
checked, goto, public, unchecked,
class, if, readonly, unsafe,
const, implicit, ref, ushort,
continue, in, return, using,
decimal, int, sbyte, virtual,
default, interface, sealed, volatile,
delegate, internal, short, void,
do, is, sizeof, while,
double, lock, stackalloc,
else, long, static,
enum, namespace, string, partial, get, set, var},
}

\lstset{language=C++,
	showspaces=false,
	showtabs=false,
	breaklines=true,
	%basicstyle=\tiny,
	basicstyle=\fontsize{9}{13}\selectfont\ttfamily,
	numbersep=5pt,
	tabsize=2,
	showstringspaces=false,
	breakatwhitespace=true,
	escapeinside={(*@}{@*)},
	commentstyle=\color{commentsColor},
	keywordstyle=\color{keywordsColor}\bfseries,
	stringstyle=\color{stringsColor},
	%basicstyle=\ttfamily
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morekeywords=
	{
		alignas,alignof,and,and\_eq,asm,auto,
		bitand,bitor,bool,break,
		case,catch,char,char16\_t,char32\_t,
		class,compl,concept,const,constexpr,
		const\_cast,continue,
		decltype,default,delete,do,double,d^ynamyc\_cast,
		else,enum,explicit,export,extern,
		false,float,for,friend,
		goto,
		if,inline,int,
		long,
		mutable,
		namespace,new,noexcept,not,not\_eq,nullptr,
		operator,or,or\_eq,
		private,protected,public,
		register,reinterpret\_cast,requires,return,
		short,signed,sizeof,static,static\_assert,
		static\_cast,struct,switch,
		template,this,thread\_local,throw,true,try,
		typedef,typeid,typename,
		union,unsigned,
		virtual,void,volatile,
		wchar\_t,while,
		xor,xor\_eq
	},
}

%Setup pseudocode

%\usepackage{xcolor}

%\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lr, rulecolor=\color{blue!80!black}}
%----------------------------------------------------------------------------------------
\newcommand{\cpp}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\newcommand{\real}{$\mathbb{R}$}
\newcommand{\uinteger}{$\mathbb{N} \cup \{0\}$} 
\newcommand{\nat}{$\mathbb{N} \cup \{0\}$} 
\newcommand{\integer}{$\mathbb{Z}$}
\newcommand{\mcomma}{\mbox{,}}
\newcommand*\rfrac[2]{{}^{#1}\!/_{#2}}
\newcommand{\FEL}{\frac{1}{2}}
\newcommand*{\mathcolor}{}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

%\newcolumntype{?}{!{\vrule width 1pt}}
\definecolor{LightRed}{rgb}{1,0.89,0.88}
\definecolor{LightGreen}{rgb}{0.89,1,0.88}
\definecolor{LightBlue}{rgb}{0.89,0.88,1}
\newcolumntype{?}[1]{!{\vrule width #1pt}}
\newcolumntype{R}{>{\columncolor{LightRed}}c}
\newcolumntype{G}{>{\columncolor{LightGreen}}c}
\newcolumntype{B}{>{\columncolor{LightBlue}}c}


\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\def\der#1#2{\frac{d #1}{d #2}}
\def\pd#1#2{\frac{\partial #1}{\partial #2}}
\def\pdd#1#2#3{\frac{\partial^2 #1}{\partial #2\partial#3}}

\def\TP#1{\mathit{#1}}
\def\FN#1{\text{#1}}
\def\uv#1{„{#1}“}
\definecolor{basis1}{rgb}{0.64,0.29,0.64}
\definecolor{basis2}{rgb}{0,0.64,0.91}
\definecolor{basis3}{rgb}{0.13,0.69,0.3}
\definecolor{basis4}{rgb}{0.93,0.11,0.14}
\definecolor{basis1a}{rgb}{0.90,0.6,0.90}
\definecolor{basis2a}{rgb}{0.2,0.80,1}
\definecolor{basis3a}{rgb}{0.3,0.9,0.5}
\definecolor{basis4a}{rgb}{1,0.7,0.7}


%\definecolor{dkgreen}{rgb}{0,0.6,0}
%\definecolor{gray}{rgb}{0.5,0.5,0.5}
%\definecolor{mauve}{rgb}{0.64,0.08,0.08}

\definecolor{keywordsColor}{rgb}{0.25,0,0.5}
\definecolor{commentsColor}{rgb}{0,0.5,0}
\definecolor{stringsColor}{rgb}{0.64,0.375,0.25}
%----------------------------------------------------------------------------------------
\catcode`@=11
\def\xmatrix#1#2{\null\,\vcenter{\normalbaselines\m@th
    \ialign{\hfil$##$\hfil&&\hskip#1\hfil$##$\hfil\crcr
      \mathstrut\crcr\noalign{\kern-\baselineskip}
      #2\crcr\mathstrut\crcr\noalign{\kern-\baselineskip}}}\,}
\catcode`@=12

\title{Zrıchlenie vıpoètu splajn povrchov}
%\subtitle{Algoritmizácia, paralelizácia a implementácia splajn modelov}
\author{Bc. Viliam Kaèala}
\typprace{Diplomová}
\rok{2016}
\miesto{Košice}
\podakovanie{
 Rád by som poïakoval vedúcemu závereènej
 práce doc. RNDr. Csabovi Törökovi, CSc.
 za cenné pripomienky, odborné vedenie a obetavos poèas
 tvorby práce. Taktie by som sa rád poïakoval 
 RNDr. Lukášovi Miòovi za cenné rady a
 pomoc poèas tvorby aplikaènej èasti tejto práce.
} 
\veduci{doc. RNDr. Csaba Török, CSc.}
\konzultant{RNDr. Lukáš Miòo}
\pracovisko{Ústav informatiky}

\abstract{
	Splines are important part of computer graphics.
	It is a mathematical model of curve and surface for the "best connection" of any finite set of points.
	The term "best connection" in this case means smooth, easily calculable mathematical surface with minimal curvature.
	Use of splines in graphics varies from large variety of CAD applications, statistics or in data analysing.
	Splines exist in many forms, whether in the form of curves in the plane, a variety of three-dimensional bodies, etc..
	This work aims to desig, analyze and implement a new algorithm for counting and generating splines bicubic clamped interpolation in three-dimensional space.
}

\abstrakt{
	Splajny sú dôleitá súèas poèítaèovej grafiky.
	Jedná sa o matematickı model krivky a plochy sluiaci na èo „najlepšie spojenie“ koneènej mnoiny bodov. 
	Termín „najlepšie spojenie“ v našom prípade znamená hladká, matematicky ¾ahko vyjadrite¾ná plocha s èo najmenším zakrivením.
	Vyuitie splajnov v grafike je ve¾mi široké od rôznych CAD aplikácií, v štatistike, alebo v analıze dát.
	Splajny existujú v mnohıch formách, èi u vo forme krivky v rovine, rôznych trojrozmernıch telies, atï..
	Táto práca si dáva za cie¾ navrhnú, analyzova a implementova novı algoritmus pre bikubickú interpoláciu v trojrozmernom priestore.
}

\bibliographystyle{alpha}

\begin{document}

\maketitle
\newpage
\tableofcontents
%\listofalgorithms
\newpage
%==================================================================================================================================================================================
%\part{}
\chapter*{Úvod}

Témou diplomovej práce sú priestorové splajn povrchy, prièom naším cie¾om je preskúma nové poznatky o splajnoch, na ktorıch istı èas pracuje vedúci tejto práce doc. RNDr. Csaba Török, CSc.

Vısledok tejto práce je návrh novej metódy vıpoètu derivácií splajnu v jeho uzloch, jej porovnanie s de Boorovym postupom z ktorého vychádzame, vysvetlenie zrıchlenia a implementácia aplikácií na vizuálne a vıkonnostne porovnávanie oboch metód.

Prínos zrıchlenia vıpoètu splajnov spoèíva v lepších monostiach modelovania ¾ubovo¾nıch trojrozmernıch útvarov v podobe polynomickıch funkcií. 
Akéko¾vek zrıchlenie toti znamená monos v reálnom èase modelova zloitejšie objekty alebo fyzikálne dáta, èo je uitoèné nielen vzh¾adom na vizuálnu reprezentáciu, ale aj na skúmanie fyzikálnych vlastností ako napríklad aerodynamické vlastnosti lietadiel a podobne. 

%\obrazok{airplaneSpline.jpg}{0.4}{Splajnovı model lietadla\footnote{http://discourse.mcneel.com/uploads/default/16061/b153158e1cbcbd86.jpg}.}
\begin{center}
	\includegraphics[scale=0.3]{blueRedSpl.png}
\end{center}
%\obrazok{blureRedSpl.jpg}{0.4} % nejde spravit \footref{footnote:airplane_spline} v popise obrazka

%\footnotetext{\label{footnote:airplane_spline}Odozva je nadobúda menšie hodnoty ak je delite¾ celı.}
Technológia v ktorej tieto poznatky implementujeme je Microsoft Silverlight. 
Jedná sa o ve¾mi schopnı nástroj na tvorbu webovıch aplikácii s plnou podporou hardvérovej akcelerácie uívate¾ského prostredia a monosou tvorby rıchlej trojrozmernej grafiky. 
Vıhodou tohto frameworku je, kede beí na platforme Microsoft .NET, monos jednoduchej portácie na desktopovú prípadne mobilnú aplikáciu. 
Na vıkonnostné porovnanie nášho algoritmu s doterajším postupom však implementujeme samostatnú natívnu aplikáciu nad \cpp.

Štruktúra práce je nasledovná.

\begin{itemize}
\item{\textbf{De Boorov model a redukovanı algoritmus}}
\begin{itemize}
	\item{\textbf{Polynómy}}\newline
	Základné pojmy o polynómoch.
	\item{\textbf{Splajny}}\newline
	Definícia krivkovıch a povrchovıch splajn.
	\item{\textbf{Trojdiagonálna LU dekompozícia}}\newline
	Spôsob poèítania trojdiagonálnych sústav.
	\item{\textbf{De Boorov vıpoèet derivácií}}\newline
	V tejto èasti si vysvetlíme splajn interpoláciu pod¾a Carla de Boora. 	
	\item{\textbf{Poèítanie derivácií redukovanou sústavou}}\newline
	Ukáka modifikovaného postupu pre kubické splajny a jeho rozšírenie pre bikubické splajny.	
%	\item{\textbf{Konštrukcia splajnu}}\newline
%	Zostrojenie splajnu ako zloenej funkcie segmentov.
\end{itemize}
\item{\textbf{Zrıchlenie}}\newline
Oèakávané zrıchlenie vıpoètov novım algoritmom.
\begin{itemize}
	\item{\textbf{Procesorová architektúra}}\newline
	Tu si objasníme vplyv modernıch inštrukènıch sád na zrıchlenie redukovaného algoritmu.
	\item{\textbf{Teoretické zrıchlenie}}\newline
	Spoèítanie èasovej zloitosti  vysvetlenie vplyvu základnıch aritmetickıch a pamäovıch operácií. 
	\item{\textbf{Merané zrıchlenie}}\newline
	Vısledky z našej implementácie.
\end{itemize}
\item{\textbf{Implementácia a uívate¾ská príruèka}}\newline
Podrobnosti implementácie v MS Silverlight a \cpp. 
Struènı návod na pouitie programov.
\end{itemize}

Formálne tézy diplomovej práce sú:

\begin{itemize}
	\item
	Analıza modelov interpolaènıch splajnov.
	\item
	Redukovanı algoritmus vıpoètu koeficientov splajn povrchov.
	\item
	Testovanie faktorov vplıvajúcich na rıchlos vıpoètu splajn koeficientov
%	\begin{itemize}
%		\item
%		Klasickı a Hermitov splajn
%		\item
%		De Boorov a redukovanı algoritmus
%		\item
%		Vplyv latencie a priepustnosti procesorovıch inštrukcií a vyrovnávacích pamätí.  
%	\end{itemize}
\end{itemize}

\chapter{De Boorov model a redukovanı algoritmus}

V tejto kapitole si postupne zadefinujeme pojem polynómu a tento postupne rozšírime na pojem splajnu. 
Následne si popíšeme dve metódy vıpoètu derivácií splajnu a konštrukciu celej splajnovej plochy.

\section{Polynómy}

Pre úplnos skôr ne si povieme o splajnoch, predstavíme si pojem polynomickej funkcie ktorı je neoddelite¾nou súèasou pri definícii splajnu. 
\begin{df}
	Nech $n$ je z \uinteger a pre kadé $i$ z $\{0, \dots, n\}$ je $a_i$ z \real, prièom $a_n \ne 0$. Funkciu $p: \mathbb{R} \to \mathbb{R}$ tvaru
	$$p(x)=\sum_{i = 0}^{n}a_i x^i$$
	nazveme \pojem{polynomická funkcia jednej premennej stupòa $n$}.
\end{df}
\begin{oznac}
	Polynomické funkcie jednej premennej budeme skrátene nazıva \pojem{polynomické funkcie}.
	Polynomické funkcie stupòa $3$ nazveme \pojem{kubické funkcie}.
\end{oznac}
V práci však budeme pracova najmä s funkciami dvoch premennıch. Analogicky si pre dve premenné zadefinujme aj polynomické funkcie.
\begin{df}
	Nech $n$ a $m$ sú z \uinteger a pre kadé $i$ z $\{0, \dots, n\}$ a $j$ z $\{0, \dots, m\}$ je $a_{ij}$ z \real, prièom $a_{nm} \ne 0$. Funkciu $p: \mathbb{R} \times \mathbb{R} \to \mathbb{R}$ tvaru
	$$p(x,y)=\sum_{0}^{n}\sum_{0}^{m}a_{ij} x^i y^j$$
	nazveme \pojem{polynomická funkcia dvoch premennıch stupòov $n$ a $m$}
\end{df}
\begin{oznac}
	Polynomické funkcie dvoch premennıch budeme skrátene nazıva \pojem{bipolynomické funkcie}.
	Bipolynomické funkcie stupòov $3$ a $3$ nazveme \pojem{bikubické funkcie}.
\end{oznac}

\section{Splajny}
V našej práci pracujeme s hermitovskımi splajnami \cite{her_nat}, ktoré sú štandardne triedy $C^1$, teda splajnami ktorıch prvé derivácie v uzloch sa rovnajú. 
 
Najbenejšie kubické splajny triedy $C^2$, teda tie pri ktorıch v uzloch máme zaruèenú rovnos aj derivácií druhého rádu, sú \pojem{naturálne} a \pojem{clamped} splajny. Pre naše potreby budeme uvaova iba druhé menované prièom ich budeme konštruova pouitím hermitovskıch bázovıch funkcíí (pozri èas \ref{sec:her_constr}).%, prièom ich budeme struène nazıva \pojem{hermitovské splajny}.  

Keïe naším cie¾om je zrıchlenı algoritmus poèítania povrchovıch splajnov, ktorı vznikol zovšeobecnením algoritmu pre krivkové splajny tak si zavedieme pojem splajnu pre krivky aj plochy.
Iste by bolo mono elegantnejšie zadefinova splajn všeobecne, ale rozdelenie definície špeciálne pre krivkové splajny v rovine a povrchové v priestore bude èitate¾nejšie.  
Formálna definícia krivkového splajnu v rovine \cite{splines} je nasledovná.
\begin{df}\label{df:curve_spline}
	Nech $I \ge 0$ je prirodzené èíslo, $(u_0, \dots,u_{I-1})$ je rastúca postupnost.
	Nech pre kadé $i$ z $\{0, 1, \dots I-2\}$ funkcie $S_{i}$ sú polynomické funkcie premennej $x$, ktoré spåòajú
	\begin{itemize}
		\item
		$S_{i}(u_{i+1}) = S_{i+1}(u_{i+1})$,
		\item
		$\der{S_{i}}{x}(u_{i+1}) = \der{S_{i+1}}{x}(u_{i+1})$ 
	\end{itemize}
	Funkciu $S$ z intervalu $[u_{0}, u_{I-1}]$ do $\mathbb{R}$ pre ktorú platí:
	\begin{equation}
	S(x) = \begin{cases}
	S_{0}(x) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	S_{1}(x) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	\vdots\\
	S_{I-1}(x) & \text{pre } x \in [u_{0}, u_{1}] \text{,}\\
	\end{cases}
	\end{equation}
	nazveme \pojem{krivkovı splajn na uzloch $(u_0, \dots,u_{I-1})$}.
\end{df}

\begin{oznac}
	Pri oznaèeniach z predchádzajúcej definície oznaème:
	\begin{itemize}
		\item
		Funkcie $S_{i}$ nazveme \pojem{segmenty splajnu}.
		\item
		Hodnoty $u_i$ nazveme \pojem{uzly}.
		\item
		Uzly $u_0$ a $u_{I-1}$ nazveme \pojem{krajné uzly}.
		\item
		$z_{i} = S(u_i)$ nazveme \pojem{funkèné hodnoty splajnu v uzloch}.
		\item
		$d_{i} = \der{S(u_i)}{x}$ nazveme \pojem{derivácie v uzloch}.
	\end{itemize}
\end{oznac}

Na to aby sme zostrojili segmenty splajnu potrebujeme ma dané uzly, funkèné hodnoty v uzloch aj derivácie v uzloch.
Je však moné zostroji splajn aj keï okrem uzlov a funkènıch hodnôt máme známe len dve krajné derivácie $d_0$ a $d_{I-1}$. 
Zvyšné hodnoty derivácií toti môeme s malou odchılkou vypoèíta napríklad De Boorovov interpoláciou.
Túto techniku, ale pre splajnové povrchy, si rozoberieme v následujúcich èastiach kapitoly. 
Teraz rozšírime túto definíciu na povrchovı splajn v priestore.

\begin{df}\label{df:surface_spline}
Nech $I \ge 0$ a  $J \ge 0$ sú prirodzené èísla, $(u_0, \dots, u_{I-1})$ a $(v_0, \dots, v_{J-1})$ sú rastúce postupnosti.
Nech pre kadé $i$ z $\{0, 1, \dots, I-2\}$ a $j$ z $\{0, 1, \dots, J-2\}$ funkcie $S_{i,j}$ sú bipolynomické funkcie premennıch $x$ a $y$, ktoré spåòajú
\begin{itemize}
\item
$S_{i,j}(u_{i+1}, y) = S_{i+1,j}(u_{i+1}, y)$,
\item 
$S_{i,j}(x, v_{j+1}) = S_{i,j+1}(x, v_{j+1})$,
\item
$\pd{S_{i,j}}{x}(u_{i+1}, y) = \pd{S_{i+1,j}}{x}(u_{i+1}, y)$ 
\item
$\pd{S_{i,j}}{y}(x, v_{j+1}) =\pd{S_{i,j+1}}{y}(x, v_{j+1})$,
%\item
%$\pdd{S_{i,j+1}}{x}{y}(x, v_{j+1}) =\pd{S_{i,j}}{y}(x, v_{j+1})$.
%$\pdd{S(u_i, v_i)}{x}{y} = \pdd{S(u_{i+1}, v_j)}{x}{y} = \pdd{S(u_i, v_{j+1})}{x}{y} = \pdd{S(u_{i+1}, v_{j+1})}{x}{y}$.
\end{itemize}
Funkciu $S$ z intervalu $[u_{0}, u_{I-1}] \times [v_{0}, v_{J-1}]$ do $\mathbb{R}$ pre ktorú platí:
	\begin{equation}
	S(x,y) = \begin{cases}
	S_{0,0}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{0}, v_{1}] \text{,}\\
	S_{0,1}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{1}, v_{2}] \text{,}\\
	\vdots\\
	S_{0,J-1}(x,y) & \text{pre } (x, y) \in [u_{0}, u_{1}] \times [v_{J-2}, v_{J-1}] \text{,}\\
	S_{1,0}(x,y) & \text{pre } (x, y) \in [u_{1}, u_{2}] \times [v_{0}, v_{1}] \text{,}\\
	\vdots\\
	S_{1,J-1}(x,y) & \text{pre } (x, y) \in [u_{1}, u_{2}] \times [v_{J21}, v_{J-1}] \text{,}\\
	\vdots\\
	S_{I-1,0}(x,y) & \text{pre } (x, y) \in [u_{I-2}, u_{I-1}] \times [v_{0}, v_{1}] \text{,}\\
	\vdots\\
	S_{I-1,J-1}(x,y) & \text{pre } (x, y) \in [u_{I-2}, u_{I-1}] \times [v_{J-2}, v_{J-1}] \text{,}
	\end{cases}
	\end{equation}
	nazveme \pojem{splajn na uzloch $(u_0, \dots,u_{I-1})$ a $(v_0, \dots,v_{J-1})$}.
\end{df}

\begin{oznac}
	Pre úplnos analogicky ako pri krivkách oznaème:
	\begin{itemize}
		\item
		Funkcie $S_{ij}$ nazveme \pojem{segmenty splajnu}.
		\item
		Dvojice $\langle u_i, v_j \rangle$ nazveme \pojem{uzly}.
		\item
		Uzly $\langle u_0, v_0\rangle$, $\langle u_{I-1}, v_0\rangle$, $\langle u_0, v_{J-1}\rangle$ a $\langle u_{I-1}, v_{J-1}\rangle$ nazveme \pojem{rohové uzly}.
		\item
		$z_{i,j} = S(u_i, v_j)$ nazveme \pojem{funkèné hodnoty splajnu v uzloch}.
		\item
		$d^x_{i,j} = \pd{S(u_i, v_j)}{x}$ nazveme \pojem{(smerové) $x$-ové derivácie v uzloch}.
		\item
		$d^y_{i,j} = \pd{S(u_i, v_j)}{y}$ nazveme \pojem{(smerové) $y$-ové derivácie v uzloch}.
		\item
		$d^{xy}_{i,j} = \pdd{S(u_i, v_j)}{x}{y}$ nazveme \pojem{zmiešané derivácie v uzloch}.
	\end{itemize}
\end{oznac}

Aby sme zostrojili splajnové segmenty potrebujeme ma dané všetky uzly aj funkèné hodnoty v uzloch a derivácie v uzloch.
Analogicky ako pri krivkách, ak nemáme známe všetky derivácie, vieme napriek tomu zvyšné derivácie dopoèíta De Boorovov interpoláciou s malou odchılkou aby splajn bol spojitı a hladkı.
Na zostrojenie splajnu pomocou De Boorovho modelu interpolácie potrebujeme ma známe
\begin{itemize}
	\item
	postupnosti uzlov $(u_0, \dots, u_{I-1})$ a $(v_0, \dots, v_{I-1})$,
	\item
	funkèné hodnoty $\{z_{0,0}, \dots, z_{I-1,0}, \dots, z_{0,J-1}, \dots, z_{I-1,J-1}\}$,
	\item
	smerové derivácie $\{d^x_{0,0}, \dots, d^x_{I-1,0}, d^x_{0,J-1}, \dots, d^x_{I-1,J-1}\}$, 
	\item
	smerové derivácie $\{d^y_{0,0}, \dots, d^y_{0,J-1}, d^y_{I-1,0}, \dots, d^y_{I-1,J-1}\}$, 
	\item
	zmiešané derivácie $\{d^{xy}_{0,0}, d^{xy}_{I-1,0}, d^{xy}_{0,J-1}, d^{xy}_{I-1,J-1}\}$.
\end{itemize}
\obrazok{DeBoorModel.png}{0.7}{De Boorov model vstupnıch hodnôt pre splajnovı povrch.}

Kım v prípade splajnovıch kriviek bolo evidentné hneï od zaèiatky ich vıskumu a aplikácie, e okrem uzlov a funkènıch hodnôt $(z_0, \dots,z_{I-1})$ v uzloch je potrebné zada ešte dve podmienky, v našom prípade sú to dve hodnoty $d_0$ a $d_{I-1}$.
V prípade interpolaènıch splajnovıch povrchoch nebolo zrejmé ktoré smerové a zmiešané derivácie je potrebné zada.
De Boor navrhol vhodnı model, ktorı okrem hodnôt $z_{i,j}$ na mrieke ve¾kosti $I \times J$ vyaduje zadanie smerovıch derivácií na okrajoch mrieky uzlov a štyri zmiešané derivácie v rohoch.

Prirodzene vidie, e takto definovanı krivkovı aj povrchovı splajn je triedy $C^1$. 
Pri vhodne zvolenıch hodnotách derivácií v uzloch vieme ale zaruèi rovnos aj druhıch derivácií, èim dostaneme splajn z triedy $C^2$ èo nám zaruèí hladkos \pojem{spojenia} jednotlivıch segmentov. 
Splajny sa taktie dajú poui na interpoláciu matematickıch funkcií. 

\begin{df}
Nech $S$ je splajn na uzloch $(u_0, \dots,u_{I-1})$ a $(v_0, \dots,v_{J-1})$ a $f: [u_0, v_0]\times  u_{I-1}, v_{J-1} \to \mathbb{R}$ je spojitá funkcia.
Hovoríme, e splajn $S$ interpoluje funkciu $f$ ak platia tieto podmienky
\begin{itemize}
	\item
	$z_{i,j} = f(u_i, v_j)$, pre kadé $i$ z $\{0, \dots, I-1\}$ a pre kadé $j$ z $\{0, \dots, J-1\}$.
	\item
	$d^x_{i,j} = \pd{f(u_i, v_j)}{x}$, pre kadé $i$ z $\{0, \dots, I-1\}$ a pre kadé $j$ z $\{0, J-1\}$.
	\item
	$d^y_{i,j} = \pd{f(u_i, v_j)}{y}$, pre kadé $i$ z $\{0, I-1\}$ a pre kadé $j$ z $\{0, \dots, J-1\}$.
	\item
	$d^{xy}_{i,j} = \pdd{f(u_i, v_j)}{x}{y}$, pre kadé $i$ z $\{0, I-1\}$ a pre kadé $j$ z $\{0, J-1\}$.
\end{itemize}
\end{df}

Na splajn interpolujúci funkciu $f$ môeme aplikova De Boorovu interpoláciu a zo získanıch derivácií u vieme zostroji jeho segmenty.
Takto získanı splajn bude danú funkciu interpolova, teda ju \pojem{napodobní}. 
To je iadané napríklad v grafickom modelovaní, pretoe pre poèítaè je jednoduchšie a rıchlejšie pracova s polynómom interpolujúcim napríklad goniometrickú funkciu ako priamo s òou. 

Obecne splajny minimalizujú integrál druhej derivácie funkcie (napr. zakrivenie, energie, ...).
Poskytujú prunı nástroj na modelovanie reálnych situácií na lokálne poiadavky, prièom ich vıpoèet je rıchly a stabilnı. 
Navyše sa dá ukáza, e interpolácia funkcie kubickım splajnom je jednoznaèná. 
Témou tejto práce sú práve metódy vıpoètu prvıch derivácií, ktorımi je moné dosiahnu práve spomenutı cie¾.
\obrazok{mexHatWKnots.png}{0.7}{Funkcia $sin(\sqrt{x^2+y^2})$ interpolovaná bikubickım splajnom.}

Základná téma našej práce je úloha na základe vstupnıch uzlov $u_{0}$, ..., $u_{I-1}$, $v_{0}$, ..., $v_{J-1}$ a funkènıch hodnôt $z_{0,0}$, ..., $z_{I,J}$ nájs \pojem{hladkú}, po èastiach definovanú funkciu $S: [u_0, u_{I+1}] \times [v_0, v_{J+1}] \to \mathbb{R}$ so spojitımi deriváciami prvého aj druhého rádu takú, e pre kadé $i \in  {0, \dots, I-1}$ a $j \in  {0, \dots, J-1}$ platí $z_{i,j} = S(u_i, v_j)$. 
%Funkèné hodnoty a hodnoty derivácií $S$ v uzloch sú èo najblišie hodnotám derivácií $f$. 
Funkciu $S$ nazıvame splajn (konkrétne povrchovı splajn), prièom jednotlivé èasti nazveme \pojem{segmenty}. 

\obrazok{fseg.png}{0.5}{\label{pic:fseg}Ukáka uzlov pre štvorsegmentovı splajn.}

\subsection{Konštrukcia hermitovho splajnu}
\label{sec:her_constr}
Teraz si ukáeme ako môeme pod¾a zadanıch uzlov, ich funkènıch hodnôt a derivácií zostroji segmenty splajnu ako funkcie dvoch premennıch v priestore.
Predpokladajme $I \ge 3$ a $J  \ge 3$ z \uinteger, rovnomerné uzly $u_0$, \dots, $u_{I-1}$ a $v_0$, \dots, $v_{J-1}$. 
Úlohou je zostroji splajn $S$ triedy $C^2$ interpolujúci funkciu $f$.
Polome
\begin{itemize}
	\item
	funkèné hodnoty splajnu $z_{0,0}$, \dots, $z_{I-1,0}$, \dots, $z_{0,J-1}$, \dots, $z_{I-1,J-1}$, 
	\item
	$x$-ové derivácie splajnu  $d^x_{0,0}$, \dots, $d^x_{I-1,0}$, \dots, $d^x_{0,J-1}$, \dots, $d^x_{I-1,J-1}$,
	\item
	$y$-ové derivácie splajnu  $d^y_{0,0}$, \dots, $d^y_{I-1,0}$, \dots, $d^y_{0,J-1}$, \dots, $d^y_{I-1,J-1}$,
	\item
	zmiešané derivácie splajnu  $d^{xy}_{0,0}$, \dots, $d^{xy}_{I-1,0}$, \dots, $d^{xy}_{0,J-1}$, \dots, $d^{xy}_{I-1,J-1}$.
\end{itemize}

%a inicializujme ich pod¾a \ref{eq:deboor_input}.

%Ïalším krokom je vypoèítanie zvyšnıch hodnôt derivácií buï plnım alebo redukovanım algoritmom. 
%Vıstupom oboch sú rovnaké hodnoty derivácií, ktoré nám zaruèia spojitos a hladkos medzi jednotlivımi segmentami budovaného splajnu, èím pod¾a definície bude patri práve do triedy $C^2$.

Máme všetky potrebné hodnoty aby sme mohli definova segmenty splajnu $S$ pod¾a definície \ref{df:surface_spline}. 
Pre kadé $i$ z $\{0, \dots, I-2\}$ a $j$ z $\{0, \dots, J-2\}$ polome segment $S_{i,j}: [u_i, v_j] \times [u_{i+1}, v_{j+1}] \to \mathbb{R}$ vzahom:
\begin{equation}
\begin{gathered}
S_{i,j}(x,y) =\\ \pmb{\lambda}^\text{T}(x, u_i, u_{i+1}) \cdot \pmb{\Phi}(u_i, u_{i+1}, v_j, v_{j+1}) \cdot \pmb{\lambda}(y, v_{j}, v_{j+1})\text{,}
\end{gathered}
\end{equation}
kde 
\begin{equation}
\begin{gathered}
\pmb{\lambda}(t, t_0, t_1) =\\ \left(\frac{(t-t_1)^2(1-2\frac{t-t_0}{t_0-t_1})}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(1-2\frac{t-t_1}{t_1-t_0})}{(t_1 - t_0)^2}, \frac{(t-t_1)^2(t-t_0)}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(t-t_1)}{(t_1 - t_0)^2} \right)^\text{T} \text{,}
\end{gathered}
\end{equation}
\begin{equation}
\begin{gathered}
\pmb{\Phi}(t_0, t_1, s_0, s_1) =\\ \left(\frac{(t-t_1)^2(1-2\frac{t-t_0}{t_0-t_1})}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(1-2\frac{t-t_1}{t_1-t_0})}{(t_1 - t_0)^2}, \frac{(t-t_1)^2(t-t_0)}{(t_0 - t_1)^2}, \frac{(t-t_0)^2(t-t_1)}{(t_1 - t_0)^2} \right)^\text{T} \text{,}
\end{gathered}
\end{equation}
%\begin{lema}
%	\label{lema:spline_interpolation}
%	Nech sú splnené podmienky na zaèiatku tejto èasti.
%	Splajn $S$ na rovnomerne rastúcich uzloch s vyššie definovanımi segmentami a deriváciami v uzloch vypoèítanıch pod¾a plného alebo pod¾a redukovaného algoritmu je triedy $C^2$ a interpoluje funkèné hodnoty $z_{0,0}$, \dots, $z_{I-1,0}$, \dots, $z_{0,J-1}$, \dots, $z_{I-1,J-1}$.
%\end{lema}
Ak $i$ je z $\{0, \dots, I-2\}$ a $j$ je z $\{0, \dots, J-2\}$, tak štvorice uzlov $(u_i, v_j)$, $(u_i, v_{j+1})$, $(u_{i+1}, v_j)$ a $(u_{i+1}, v_{j+1})$ tvoria obdånikovı úsek nad ktorım sa nachádza splajnovı segment. Kadı segment $S_{i,j}$ je bikubická funkcia z $[u_i, u_{i+1}] \times [v_j, v_{j+1}]$ do $\mathbb{R}$. 
Vısledná funkcia $S$ teda vznikne zjednotením segmentov $S_{i,j}$. 
Na vypoèítanie kadého segmentu potrebujeme štyri uzly, a pre kadı uzol príslušne hodnoty $z_{i,j}$, $d^x_{i,j}$, $d^y_{i,j}$ a $d^{xy}_{i,j}$. 

\pozn{
Hodnoty $z_{i,j}$ musíme ma vdy vopred dané. Derivácie $d^x_{i,j}$, $d^y_{i,j}$ a $d^{xy}_{i,j}$ buï môu by dané všetky, alebo iba niektoré a z nich vieme s malou odchılkou vypoèíta hodnoty ostatnıch. 
Jeden z tıchto spôsobov spoèíva v De Boorovej interpolácii ktorú si v ïalších dvoch èastiach objasníme. 
Potom predstavíme modifikovanı spôsob interpolácie špeciálne pre splajny s rovnomerne rastúcimi uzlami.
}

\section{Trojdiagonálna LU dekompozícia}
\label{sec:tridiagonal}
Základ De Boorovej interpolácie tkvie v opakovanom poèítaní systémov trojdiagonálnych lineárnych rovníc. 

\begin{df}
	Nech $n \ge 3$ je z \uinteger. Sústavu rovníc tvaru
	\begin{equation}\label{eq:lu}
	\begin{pmatrix}
	b_0 & c_0 & 0 & \hdots & 0 & 0\\
	a_0 & b_1 & c_1 & \hdots & 0 & 0\\
	0 & a_1 & b & \hdots & 0 & 0\\
	\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
	0 & 0 & 0 & \hdots & b & c_{n-2} \\
	0 & 0 & 0 & \hdots & a_{n-2} & b_{n-1}\\
	\end{pmatrix} 
	\cdot
	\begin{pmatrix}
	x_1\\
	x_2\\
	x_3\\
	\vdots \\
	x_{n-1}\\
	x_{n}\\
	\end{pmatrix}
	=
	\begin{pmatrix}
	r_1\\
	r_2\\
	r_3\\
	\vdots \\
	r_{n-1}\\
	r_{n}\\
	\end{pmatrix}
	\end{equation}
	nazveme \pojem{trojdiagonálna sústava lineárnych rovníc}.
\end{df}

Jeden z efektívnych spôsobov riešenia tıchto rovníc spoèíva v $LU$ dekompozícii $A\mathbf{x} = L\underbrace{U\mathbf{x}}_{\mathbf{y}} = \mathbf{r}$, kde maticu $A$ rozloíme na súèin matíc $L$ a $U$ v tvare
\begin{equation}
A = 
\begin{pmatrix}
1 & 0 & 0 & \hdots & 0 & 0\\
l_1 & 1 & 0 & \hdots & 0 & 0\\
0 & l_2 & 1 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & 1 & 0 \\
0 & 0 & 0 & \hdots & l_{n-1} & 1\\
\end{pmatrix} \cdot
\begin{pmatrix}
u_0 & 1 & 0 & \hdots & 0 & 0\\
0 & u_1 & 1 & \hdots & 0 & 0\\
0 & 0 & u_2 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & \upsilon_{n-2} & 0 \\
0 & 0 & 0 & \hdots & 0 & \upsilon_{n-1}\\
\end{pmatrix}\text{.}
\end{equation}
Pre $k$ z $\{1, \dots, n\}$ sú hodnoty $\upsilon_k$ a $\lambda_k$ urèené takto:
\begin{equation} \label{eq:LU}
\upsilon_i = b \text{,} \left\{ \lambda_i = \frac{1}{\upsilon_{i-1}}, \upsilon = b - \lambda_i\right\} \text{,} i \in \{2, \dots, n\}\text{.}
\end{equation}
Pre priamy a spätnı chod máme
\begin{equation} \label{eq:FwLy}
\text{Priamy: } L\mathbf{y} = \mathbf{r} \text{, } y_1 = r_1 \text{, } \left\{ y_i = r_i - \lambda_i\right\} \text{, } i \in \{2, \dots, n\}\text{,}
\end{equation}
\begin{equation} \label{eq:BwUd}
\text{Spätnı: } U\mathbf{d} = \mathbf{y} \text{, } d_i = \frac{y_i}{u_i} \text{, } \left\{ d_i = \frac{1}{u_i}(y_i - d_{i+1})\right\} \text{,} i \in \{n-1, \dots, 1\}\text{.}
\end{equation}

LU dekompozíciou sa rieši ako de Boorova sústava (\ref{eq:deboorM}), tak aj naša redukovaná (\ref{eq:redM}).
Nišie si ukáeme optimalizovanı pseudokód tohto algoritmu prevzatı z \cite{lu_c}.
Procedúra algoritmu je priestorovo optimalizovaná kde LU rozklad robíme priamo na vstupnıch vektoroch predstavujúce diagonály a vısledok ukladáme do vektora obsahujúci pravú stranu.
%\newpage
\begin{algorithm}
	\caption{Všeobecná LU dekompozícia
		\label{alg:SolveGeneralLU}}
	\begin{algorithmic}[1]
		\Procedure{VyriešLU}{}
		\State \textbf{vstup:}	
		\State
		$a[0..n-2]$ spodná diagonála
		\State
		$b[0..n-1]$ hlavná diagonála
		\State
		$c[0..n-2]$ horná diagonála, po skonèení sa nezachová
		\State
		$r[0..n-1]$ pravá strana
		\State \textbf{vıstup:} $r[0..n-1]$ pravá strana obsahujúca vısledok 
		\State
		
		%	$p \gets [0..n-1]$
		\State $c[0]\gets \sfrac{c[0]}{b[0]}$
		\State $r[0]\gets \sfrac{r[0]}{b[0]}$
		\Comment Priamy prechod
		\For{$i$ \textbf{od} $1$ \textbf{a} $n-1$} 
		\State $m \gets \sfrac{1}{b[i]-a[i]\cdot c[i-1]}$
		\State $c[i] \gets m\cdot c[i]$
		\State $r[i] \gets m\cdot (r[i] - a[i]\cdot r[i-1])$
		\EndFor
		\Comment Spätnı prechod
		\For{$i$ \textbf{od} $n-2$ \textbf{a} $0$} 	
		\State $r[i] \gets r[i] - c[i]\cdot r[i+1]$
		\EndFor
		\EndProcedure		
	\end{algorithmic}
\end{algorithm}

\begin{lema}
Nech $n$ je poèet rovníc trojdiagonálnej lineárnej sústavy.
Algoritmus \ref{alg:SolveGeneralLU} nájde riešenie v lineárnom èase, prièom vyaduje $5n$ pamäte.
\end{lema}

V prípade poèítania derivácií je sústava rovníc v špeciálnom tvare pod¾a \ref{eq:deboorM} pre plnı alebo \ref{eq:redM} pre redukovanı algoritmus v následujúcich èastiach.
V oboch prípadoch všetky èísla na hornej aj spodnej diagonále majú hodnotu $1$. 
Na hlavnej diagonále sú to hodnoty $4$ pri plnom algoritme a v prípade redukovaného postupu sú to hodnoty $-14$. 
Poslednı prvok diagonály tie môe obsahova hodnotu $-15$ ak poèet rovníc je párny. 
Teda pri implementácii si nemusíme pamäta vektory, staèí nám zapamäta si iba štyri hodnoty. 
Upravenı algoritmus, ktorı rieši LU dekompozíciu špeciálne pre plnı a redukovanı algoritmus je nišie. 
\newpage
\begin{algorithm}
	\caption{Špeciálna LU dekompozícia
		\label{alg:SolveLU}}
	\begin{algorithmic}[1]
		\Procedure{VyriešLU}{}
		\State \textbf{vstup:}	
		\State
		\State
		$b$ hodnota prvkov hlavnej diagonály
		\State
		$b_l$ hodnota posledného prvku hlavnej diagonály
		\State
		$r[0..n-1]$ pravá strana
		\State \textbf{vıstup:} $r[0..n-1]$ pravá strana obsahujúca vısledok 
		\State
		
		\State$p \gets [0..n-2]$
		\Comment Pomocnı vektor nahradzujúci hornú diagonálu
		\State $m \gets \sfrac{1}{b}$
		\State $p[0]\gets q$
		\State $r[0]\gets q \cdot r[0]$
		\For{$i$ \textbf{od} $1$ \textbf{a} $n-2$} 
		\State $q \gets \sfrac{1}{b - p[i-1]}$
		\State $p[i] \gets m$
		\State $r[i] \gets m\cdot (r[i] - r[i-1])$
		\EndFor
		\State $m \gets \sfrac{1}{b_l - p[n-1]}$
		\State $p[i] \gets m$
		\State $r[i] \gets m\cdot (r[n-1] - r[n-2])$
		\For{$i$ \textbf{od} $n-2$ \textbf{a} $0$} 	
		\State $r[i] \gets r[i] - p[i]\cdot r[i+1]$
		\EndFor
		\EndProcedure	
	\end{algorithmic}
\end{algorithm}

\begin{lema}
	Nech $n$ je poèet rovníc trojdiagonálnej lineárnej sústavy, všetky prvky na spodnej a hornej diagonále majú hodnotu $1$ a pre hodnoty $b_0$, $b_1$, ..., $b_{n-1}$ na hlavnej diagonále platí $b_0 = b_1 = \dots b_{n-2}$.
	Algoritmus \ref{alg:SolveLU} nájde riešenie v lineárnom èase, prièom vyaduje $2n$ pamäte.
\end{lema}

Tento modifikovanı algoritmus má menej ne polovièné pamäové nároky ne v prípade všeobecnıch trojdiagonálnych sústav, èo nám v praxi umoòuje rieši väèšie úlohy. 
Navyše pri reálnej implementácií nemusíme vektory $r$ a $p$ inicializova pri kadom volaní procedúry \pojem{VyriešLU} ale namiesto toho môeme poui prednaèítané vyrovnávacie vektory, tzv. \pojem{buffery}.
To nám ušetrí mnoho strojovıch cyklov, ktoré procesor strávi neustálym alokovaním a zmazaním potrebnej operaènej pamäte. 

Máme u potrebnı základ aby sme mohli prejs k cie¾u práce a tım je práve De Boorov vıpoèet derivácií splajnu a z neho odvodenı efektívnejší algoritmus.

\section{De Boorov vıpoèet derivácií}
\label{sec:full_deboor}

Skôr ne zaèneme s popisom De Boorvho modelu vıpoètu derivácií v uzloch si polome dve oznaèenia s ktorımi budeme pracova.

\begin{oznac}
	Postupnos $(a_0, a_1, \dots)$ nazveme \pojem{rovnomere rastúcou} ak pre ¾ubovo¾né $i$ z $\{0, 1, \dots\}$ platí $a_{i+1} > a_i$ a 
	pre ¾ubovo¾né $i$,$j$ z $\{0, 1, \dots\}$ platí $a_{j+1} - a_j = a_{i+1} - a_i$.
\end{oznac}

\begin{oznac}
	Pre rovnomerne rastúcu postupnos $(a_0, a_1, \dots)$ oznaème hodnotu $h_a = a_1 - a_0$.
\end{oznac}

Nech sú dané rovnomerne rastúce postupnosti uzlov $(u_0,$ \dots$, u_{I-1})$ a  $(v_0,$ \dots$, v_{J-1})$, kde $I$,$J$ sú z \uinteger, prièom chceme interpolova funkèné hodnoty $\{z_{0,0},$ \dots$ z_{0,J-1},$ \dots$, z_{I-1,0},$ \dots$, z_{I-1, J-1}\}$. 
Vıslednı splajn bude teda tvorenı $(I-1) \cdot (J-1)$ segmentami. 
Ako bolo spomenuté, kadı segment splajnu potrebuje na svoje zostrojenie štyri uzly a hodnoty $z$, $d^x$, $d^y$ a $d^{xy}$. 
Získanie derivácií však môe by niekedy nákladné. 
Príkladom môe by v prípad, keï funkèné hodnoty $z_{i,j}$ sú získané vyhodnotením nejakej funkcie $f$.
To môe by v praxi na poèítaèi znaène pomalé najmä v prípade, ak pracujeme so symbolicky zapísanou funkciou vo forme textového reazca, ktorú je potrebné dynamicky interpretova poèas behu programu. 

Algoritmus nájdenı Carlom de Boorom \cite{deboor} umoòuje s malou odchılkou vypoèíta hodnoty derivácií v uzloch na základe následujúcich vstupnıch hodnôt, ktoré máme dané:
\begin{itemize}\label{eq:deboor_input}
	\item
	$z_{i,j}$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^x_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^y_{i,j }$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, J-1\}$.
	\item
	$d^{xy}_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, J-1\}$.
\end{itemize}

\pozn{
	De Boorova interpolácia vo všeobecnosti nepredpokladá len rovnomerne rastúce postupnosti uzlov $(u_0, \dots,u_I)$ a $(v_0, \dots,v_J)$. 
	Náš postup v ïalšej èasti èlánku ale funguje len s takımito postupnosami. 
	Preto v tejto èasti budeme uvaova De Boorov postup špeciálne pre rovnomerne rastúce postupnosti uzlov.
}

\begin{pr}
Na príklade uzlov z obrázka \ref{pic:fseg} potrebujeme pozna hodnoty následovne:
\begin{itemize}
	\item
	$z_{0,2}$, $z_{1,2}$, $z_{2,2}$,\newline
	$z_{0,1}$, $z_{1,1}$, $z_{2,1}$,\newline
	$z_{0,0}$, $z_{1,0}$, $z_{2,0}$,\newline  
	\item
	$d^x_{0,2}$, \phantom{$d^x_{1,2}$}, $d^x_{2,2}$,\newline
	$d^x_{0,1}$, \phantom{$d^x_{1,1}$}, $d^x_{2,1}$,\newline
	$d^x_{0,0}$, \phantom{$d^x_{1,0}$}, $d^x_{2,0}$,\newline 
	\item
	$d^y_{0,2}$, $d^y_{1,2}$, $d^y_{2,2}$,\newline
	\phantom{$d^y_{0,1}$}, \phantom{$d^y_{1,1}$}, \phantom{$d^y_{2,1}$},\newline
	$d^y_{0,0}$, $d^y_{1,0}$, $d^y_{2,0}$,\newline
	\item
	$d^{xy}_{0,2}$, \phantom{$d^{xy}_{1,2}$}, $d^{xy}_{2,2}$,\newline
	\phantom{$d^{xy}_{0,1}$}, \phantom{$d^{xy}_{1,1}$}, \phantom{$d^{xy}_{2,1}$},\newline
	$d^{xy}_{0,0}$, \phantom{$d^{xy}_{1,0}$}, $d^{xy}_{2,0}$,\newline  
\end{itemize}
\end{pr}

Zvyšné derivácie $d^x$, $d^y$ a $d^{xy}$ vieme jednoznaène vypoèíta pomocou $2(I) + J + 5$ lineárnych sústav s celkovo $3IJ + I + J + 2$ rovnicami.
Nišie uvádzame modelové rovnice, pomocou ktorıch sú zostrojené tieto sústavy lineárnych rovníc.
\newline\newline
Pre $j \in \{0, \dots, J-1\}$, teda pre kadı ståpec $j$ vypoèítame parciálne derivácie $d^x$
\begin{equation}\label{eq:deboor1}
\begin{split}
d^x_{i+1,j} + 4d^x_{i,j} + d^x_{i-1,j}
= \frac{3}{h_u}(z_{i+1,j} - z_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $j \in \{0, J-1\}$, teda pre prvı a poslednı ståpec vypoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:deboor2}
\begin{split}
d^{xy}_{i+1,j} + 4d^{xy}_{i,j} + d^{xy}_{i-1,j}
= \frac{3}{h_u}(d^y_{i+1,j} - d^y_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $i$ vypoèítame parciálne derivácie $d^y$
\begin{equation}\label{eq:deboor3}
\begin{split}
d^y_{i,j+1} + 4d^y_{i,j} + d^y_{i,j-1}
= \frac{3}{h_v}(z_{i,j+1} - z_{i,j-1}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $j$ dopoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:deboor4}
\begin{split}
d^{xy}_{i,j+1} + 4d^{xy}_{i,j} + d^{xy}_{i,j-1}
= \frac{3}{h_v}(d^x_{i,j+1} - d^x_{i,j-1}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
\newline
Kadá z tıchto sústav má takıto maticovı tvar:
\begin{equation} \label{eq:deboorM}
\begin{pmatrix}
4 & 1 & 0 & \hdots & 0 & 0\\
1 & 4 & 1 & \hdots & 0 & 0\\
0 & 1 & 4 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & 4 & 1\\
0 & 0 & 0 & \hdots & 1 & 4\\
\end{pmatrix}
\cdot
\begin{pmatrix}
D_{1}\\
D_{2}\\
D_{3}\\
\vdots \\
D_{N-3}\\
D_{N-2}\\
\end{pmatrix}
=
\begin{pmatrix}
\frac{3}{h}(Y_{2} - Y_{0}) - D_0\\
\frac{3}{h}(Y_{3} - Y_{1})\\
\frac{3}{h}(Y_{4} - Y_{2})\\
\vdots \\
\frac{3}{h}(Y_{N-2} - Y_{N-4})\\
\frac{3}{h}(Y_{N-1} - Y_{N-3}) - D_{N-1}\\
\end{pmatrix} \text{,}
\end{equation}
kde pod¾a toho o ktorú z modelovıch rovníc sa jedná, hodnoty N, D a Y zadávame následovne. 
Nech $k$ z ${1, \dots, K-1}$. Potom
\begin{itemize}
	\item
	$N = I$, $h= h_u$,  $D_k = d^x_{k,j}$ a $Y_k = z_{k,j}$, pre rovnicu \ref{eq:deboor1},
	\item
	$N = I$, $h= h_u$,  $D_k = d^{xy}_{k,j}$ a $Y_k = d^y_{k,j}$, pre rovnicu \ref{eq:deboor2},
	\item
	$N = J$, $h= h_v$,  $D_k = d^y_{i,k}$ a $Y_k = z_{i,k}$, pre rovnicu \ref{eq:deboor3},
	\item
	$N = J$, $h= h_v$,  $D_k = d^{xy}_{i,k}$ a $Y_k = d^x_{i,k}$, pre rovnicu \ref{eq:deboor3}.
\end{itemize}

Po vypoèítaní všetkıch derivácií môeme funkèné hodnoty jednoznaène interpolova splajnom.

%\pozn{
%V aplikácií na vizualizáciu pouívame práve Hermitove splajny.
%}
%TO_CSABA: Preco hermitove?
\section{Poèítanie derivácií redukovanou sústavou}
\label{sec:red_deboor}
V rámci svojej bakalárskej práce som popisoval novı postup pre kubické splajnové krivky triedy $C^2$, teda splajny, kde interpolovaná funkcia $f$ je typu $\mathbb{R} \to \mathbb{R}$. 
Cie¾om tejto práce je analyzova a vylepši De Boorov algoritmus pre bikubické splajny z predchádzajúcej èasti na základe vıskumu \cite{szabominotorok} doc. Töröka a RNDr. Szaba o vzahu medzi bikvartickımi polynómami a bikubickımi splajnami a odvodenie sústav na základe tohto vısledku \cite{minoTorok}.

\begin{oznac}
Teraz popíšeme tento novı algoritmus, ktorı pracovne oznaèíme ako \pojem{redukovanı algoritmus}. 
Ïalej budeme pôvodnı de Boorov postup, oznaèova pojmom \pojem{plnı algoritmus}.
\end{oznac}

Vstupné hodnoty sú identické ako pri pôvodnom algoritme. 
Teda máme dané $(u_0$, ...,$u_{I-1})$ a $(v_0$, ...,$v_{J-1})$, kde $I$,$J$ sú z \uinteger, prièom chceme zostroji splajn $S$, ktorı interpoluje hodnoty $\{z_{0,0}, \dots, z_{I-1,0}, \dots, z_{0,J-1} \dots z_{I-1,J-1}\}$ aby pre kadé $i \in \{0, \dots, I-1\}$, $j \in \{0, \dots, J-1\}$ platilo $z_{i,j} = S(u_i, v_j)$.
Pre pripomenutie potrebujeme ešte pozna tieto hodnoty.
\begin{itemize}
	\item
	$d^x_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, \dots, J-1\}$.
	\item
	$d^y_{i,j}$ pre $i \in \{0, \dots, I-1\}$, $j \in \{0, J-1\}$.
	\item
	$d^{xy}_{i,j}$ pre $i \in \{0, I-1\}$, $j \in \{0, J-1\}$.
\end{itemize}  
Zvyšné derivácie $d^x$, $d^y$ a $d^{xy}$ vieme jednoznaène vypoèíta pomocou $2(I) + J + 5$ lineárnych sústav s celkovo $3IJ + I + J + 2$ rovnicami:
Nišie uvádzame modelové rovnice, pomocou ktorıch sú zostrojené tieto sústavy lineárnych rovníc. 
Oznaème $I_l$ a $J_l$ indexy po ktoré budeme iterova. 
Platí:
$$I_l = \begin{cases}
I - 2 & \text{ak } I \text{ je nepárne,}\\
I - 3 & \text{ak } I \text{ je párne,}
\end{cases}$$
\item
$$J_l = \begin{cases}
J - 2 & \text{ak } J \text{ je nepárne,}\\
J - 3 & \text{ak } J \text{ je párne,}
\end{cases}$$
Pre $j \in \{0, \dots, J-1\}$, teda pre kadı ståpec $j$ vypoèítame parciálne derivácie $d^x$
\begin{equation}\label{eq:red1}
\begin{split}
d^x_{i+2,j} - 14d^x_{i,j} + d^x_{i-2,j}
= \frac{3}{h_u}(z_{i+2,j} - z_{i-2,j}) - \frac{12}{h_u}(z_{i+1,j} - z_{i-1,j}) \text{, }\\ i \in \{2,4 \dots, I_l\}
\end{split}
\end{equation}

Rovnica je podobná ako plnom algoritme \ref{eq:deboor1}. 
Všimnime si, e sústavu rovníc teraz budujeme len pre párne indexy $i$, teda vyriešením tejto sústavy
získame iba polovicu iadanıch hodnôt $d^x$. 
Pre $i \in \{1,3 \dots, I_l\}$ a $j \in \{0, \dots, J-1\}$ zvyšné derivácie $d^x$ vypoèítame ako
\begin{equation}\label{eq:redr1}
d^x_{i,j} = \frac{3}{4h_u}(z_{i+1,j} - z_{i-1,j}) - \frac{1}{4}(d^x_{i+1,j} - d^x_{i-1,j})
\end{equation}
Pre $i \in \{0, \dots, I-1\}$, teda pre kadı riadok $i$ analogicky vypoèítame parciálne derivácie $d^y$
\begin{equation}\label{eq:red2}
\begin{split}
d^y_{i,j+2} - 14d^x_{i,j} + d^x_{i,j-2}
= \frac{3}{h_v}(z_{i,j+2} - z_{i,j+2}) - \frac{12}{h_v}(z_{i,j+1} - z_{i,j-1}) \text{, }\\ i \in \{2,4 \dots, I_l\}
\end{split}
\end{equation}
Následne analogicky pre $i \in \{1,2, \dots, I-1\}$ a $j \in \{1,3, \dots, J_l\}$ zvyšné derivácie $d^y$ vypoèítame ako
\begin{equation}\label{eq:redr2}
d^y_{i,j} = \frac{3}{4h_v}(z_{i,j+1} - z_{i,j-1}) - \frac{1}{4}(d^y_{i,j+1} - d^y_{i,j-1})
\end{equation}
Pre $j \in \{0, J-1\}$, teda pre prvı a poslednı ståpec vypoèítame parciálne derivácie $d^{x,y}$ rovnako ako pri plnom algoritme.
\begin{equation}\label{eq:red3a}
\begin{split}
d^{xy}_{i+1,j} + 4d^{xy}_{i,j} + d^{xy}_{i-1,j}
= \frac{3}{h_u}(d^y_{i+1,j} - d^y_{i-1,j}) \text{, }\\ i \in \{1, \dots, I-2\}
\end{split}
\end{equation}
Pre $i \in \{0, I-1\}$, teda pre prvı a poslednı riadok analogicky vypoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:red3b}
\begin{split}
d^{xy}_{i,j+1} + 4d^{xy}_{i,j} + d^{xy}_{i,j-1}
= \frac{3}{h_v}(d^x_{i,j-1} - d^x_{i-1,j}) \text{, }\\ j \in \{1, \dots, J-2\}
\end{split}
\end{equation}
Pre $i \in \{2,4, \dots, I_l\}$, teda pre kadı ståpec $i$ dopoèítame parciálne derivácie $d^{x,y}$
\begin{equation}\label{eq:red4}
\begin{split}
&d^{xy}_{i,j+2} + 4d^{xy}_{i,j} + d^{xy}_{i,j-2} =\\
&\frac{1}{7}(d^{xy}_{i-2,j+2} - d^{xy}_{i-2,j-2}) - 2d^{xy}_{i-2,j}\\
&+\frac{3}{7h_u}(d^y_{i-2,j+2} - d^y_{i-2,j-2}) + \frac{3}{7h_v}(-d^x_{i-2,j+2} - d^x_{i-2,j-2})\\
&+\frac{9}{7h_u}(d^y_{i,j+2} - d^y_{i,j-2}) + \frac{9}{7h_u h_v}(-z_{i-2,j+2} + z_{i-2,j-2})\\
&+\frac{12}{7h_u}(-d^y_{i-1,j+2} - d^y_{i-1,j-2}) + \frac{12}{7h_v}(d^x_{i-2,j+1} - d^x_{i-2,j-1})\\
&+\frac{3}{7h_v}(d^x_{i,j+2} - d^x_{i,j-2}) + \frac{27}{7h_u h_v}(-z_{i,j+2} + z_{i,j-2})\\
&+\frac{36}{7h_u h_v}(z_{i-1,j+2} - z_{i-1,j-2} + z_{i-2,j+1} - z_{i-,j-1})\\
&-\frac{6}{h_u}d^y_{i-2,j} + \frac{144}{7h_u h_v}(-z_{i-1,j+1} + z_{i-1,j-1})
+\frac{24}{h_u}d^y_{i-1,j}
\text{, }\\ & j \in \{4,6 \dots, J_l-2\}
\end{split}
\end{equation}
Následne vypoèítame zvyšné derivácie $d^{x,y}$.
Najprv pre $i \in \{1,3, \dots, I_l\}$ a $j \in \{1,3, \dots, J_l\}$ platí
\begin{equation}\label{eq:redr4a}
\begin{split}
d^{xy}_{i,j} &= \frac{1}{16}(d^{xy}_{i+1,j+1} + d^{xy}_{i+1,j-1} + d^{xy}_{i-1,j+1} + d^{xy}_{i-1,j-1})\\
&-\frac{3}{16h_v}(d^{x}_{i+1,j+1} - d^{x}_{i+1,j-1} + d^{x}_{i-1,j+1} - d^{x}_{i-1,j-1})\\
&-\frac{3}{16h_u}(d^{y}_{i+1,j+1} + d^{y}_{i+1,j-1} - d^{y}_{i-1,j+1} - d^{y}_{i-1,j-1})\\
&+\frac{9}{16h_u h_v}(z_{i+1,j+1} - z_{i+1,j-1} - z_{i-1,j+1} + z_{i-1,j-1})\text{. }
\end{split}
\end{equation}
Nakoniec pre $i \in \{1,3, \dots, I_l+1\}$ a $j \in \{2,4, \dots, J_l\}$
\begin{equation}\label{eq:redr4b}
d^{xy}_{i,j} = \frac{3}{4h_v}(d^x_{i,j+1} - zd^x_{i,j-1}) - \frac{1}{4}(d^{xy}_{i,j+1} - d^{xy}_{i,j-1})
\end{equation}
a pre $i \in \{2,4, \dots, I_l\}$ a $j \in \{1,3, \dots, J_l+1\}$
\begin{equation}\label{eq:redr4c}
d^{xy}_{i,j} = \frac{3}{4h_v}(d^x_{i,j+1} - zd^x_{i,j-1}) - \frac{1}{4}(d^{xy}_{i,j+1} - d^{xy}_{i,j-1})
\end{equation}

\begin{oznac}
	Zaveïme dve oznaèenia.
	\begin{itemize}
	\item
	Rovnice \ref{eq:redr1}, \ref{eq:redr2} budeme súhrne oznaèova pojmom \pojem{resty}.
	\item
	Rovnice \ref{eq:redr4a}, \ref{eq:redr4b}, \ref{eq:redr4c} budeme súhrne oznaèova pojmom \pojem{zmiešané resty}.
	\end{itemize}
\end{oznac}

Modelové sústavy rovníc \ref{eq:red1} a \ref{eq:red2} majú takıto maticovı tvar
\begin{equation} \label{eq:redM}
\begin{aligned}
\begin{pmatrix}
-14 & 1 & 0 & \hdots & 0 & 0\\
1 & -14 & 1 & \hdots & 0 & 0\\
0 & 1 & -14 & \hdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots\\
0 & 0 & 0 & \hdots & -14 & 1 \\
0 & 0 & 0 & \hdots & 1 & \mu\\
\end{pmatrix} 
\cdot
\begin{pmatrix}
D_2\\
D_4\\
D_6\\
\vdots \\
D_{v-2}\\
D_{v}\\
\end{pmatrix}
=\\
\begin{pmatrix}
\frac{3}{h}(Y_4 - Y_0) - \frac{12}{h}(Y_3 - Y_1) - D_0\\
\frac{3}{h}(Y_6 - Y_2) - \frac{12}{h}(Y_5 - Y_3)\\
\frac{3}{h}(Y_8 - Y_4) - \frac{12}{h}(Y_7 - Y_5)\\
\vdots \\
\frac{3}{h}(Y_\nu - Y_{\nu-4}) - \frac{12}{h}(Y_{\nu-3} - Y_{\nu-5})\\
\frac{3}{h}(Y_{\nu+\tau} - Y_{\nu-2}) - \frac{12}{h}(Y_{\nu-1} - Y_{\nu-3} - \theta D_{K+1})\\
\end{pmatrix}\text{,}
\end{aligned}
\end{equation}
kde 
\begin{gather} \label{eq:reducedOddD}
\begin{aligned}
%\begin{split}
\mu &= -15\text{, }\tau = 0\text{, }\theta = -4\text{, a }\nu = N \text{,}&\text{ak }K\text{ je párne,}\\
\mu &= -14\text{, }\tau = 2\text{, }\theta = 1\text{, a }\nu = N - 1 \text{,}&\text{ak }N\text{ je nepárne,}
%\end{split}
\end{aligned}
\end{gather}
a pod¾a toho o ktorú z modelovıch rovníc sa jedná, hodnoty N, D a Y zadávame následovne. 
Nech $k$ z ${1, \dots, K-1}$. Potom
\begin{itemize}
	\item
	$N = I$, $h= h_u$,  $D_k = d^x_{k,j}$ a $Y_k = z_{k,j}$, pre rovnicu \ref{eq:red1}..
	\item
	$N = J$, $h= h_v$,  $D_k = d^y_{i,k}$ a $Y_k = z_{i,k}$, pre rovnicu \ref{eq:red2}.
\end{itemize}
Analogicky vieme zostroji maticovı tvar aj pre modelovú sústavu pre derivácie $d^{xy}$ pod¾a \ref{eq:red4}.
\begin{oznac}
Špeciálne zaveïme oznaèenia pre tieto hodnoty:
\begin{itemize}
\item
Parciálne derivácie $d^x$ a $d^y$ poèítané rovnicami \ref{eq:redr1} a \ref{eq:redr2} budeme nazıva \pojem{zostatkové derivácie}.
\item
Zmiešané parciálne derivácie $d^xy$ poèítané rovnicami \ref{eq:redr4a}, \ref{eq:redr4b} a \ref{eq:redr4c} budeme nazıva \pojem{zmiešané zostatkové derivácie}.	
\end{itemize}	
\end{oznac}

Následujúca lema formálne zhrnie fakt, e splajn s vypoèítanımi deriváciami pod¾a plného alebo redukovaného algoritmu je interpolaènı.  

\begin{lema}[Miòo-Török \cite{minoTorok}]
Nech sú zadané následujúce hodnoty:
\begin{itemize}
	\item
	$I \ge 3$ a $J \ge 3$,
	\item
	$(u_0, \dots,  u_{I-1})$ a $(v_0, \dots,  v_{J-1})$ sú rovnomerne rastúce postupnosti uzlov,
	\item
	pre kadé $i$ z $\{0, \dots, I-1\}$ a $j$ z $\{0, \dots, J-1\}$ sú $z_{ij}$ funkèné hodnoty v uzloch
	\item
	pre kadé $i$ z $\{0, \dots, I-1\}$ a pre kadé $j$ z $\{0, J-1\}$ sú $d^x_{i,j}$ smerové derivácie na osi $x$,
	\item
	pre kadé $i$ z $\{0, I-1\}$ a pre kadé $j$ z $\{0, \dots, J-1\}$ sú $d^y_{i,j}$ smerové derivácie na osi $y$,
	\item
	pre kadé $i$ z $\{0, I-1\}$ a pre kadé $j$ z $\{0, J-1\}$ sú $d^{xy}_{i,j}$ zmiešané derivácie na osiach $x$ a $y$.
\end{itemize}
Ïalej nech následovné hodnoty sú vypoèítané pod¾a plného alebo redukovaného algoritmu:
\begin{itemize}
	\item
	$d^x_{i,j}$, pre kadé $i$ z $\{0, \dots, I-1\}$ a pre kadé $j$ z $\{1, \dots, J-2\}$.
	\item
	$d^y_{i,j}$, pre kadé $i$ z $\{1, \dots, I-2\}$ a pre kadé $j$ z $\{0, \dots, J-1\}$.
	\item
	$d^{xy}_{i,j}$, pre kadé $i$ z $\{0, \dots, I-1\}$ a pre kadé $j$ z $\{0, \dots, J-1\}$ okrem $d^{xy}_{0,0}$, $d^{xy}_{I-1,0}$, $d^{xy}_{0,J-1}$ a $d^{xy}_{I-1,J-1}$.
\end{itemize}
Potom splajn $S$ s vypoèítanımi segmentami pod¾a èasti \ref{sec:her_constr} s vyššie uvedenımi hodnotami interpoluje funkèné hodnoty $\{z_{0,0}, \dots z_{I-1,J-1}\}$.
\end{lema}

\subparagraph{Paralelizácia}
\label{par:thread_par}
Všimnime si, e v prípade oboch algoritmoch derivácie pod¾a jednotlivıch premennıch poèítame v vdy jednom smere.
Uvaujme napríklad vıpoèet smerovıch derivácií po osi $x$.
Jedna LU dekompozícia vypoèíta derivácie práve pre jeden riadok matice uzlov, prièom tieto vıpoèty sú vzájomne nezávislé.
To umoòuje $x$-ové derivácie na jednotlivıch riadkoch matice poèíta paralelne.
Analogická úvaha platí aj pre $y$-ové aj zmiešané derivácie. Pri zmiešanıch zostatkovıch deriváciách u redukovaného algoritmu sa situácia trocha komplikuje pretoe ich zatia¾ nevieme poèíta nezávisle na sebe. 
To má negatívny vplyv na rıchlos paralelnej verzie redukovaného algoritmu a preto bude zrıchlenie oproti paralelnému plnému algoritmu menšie ako v prípade sériovıch verzií. 
%V èasti \ref{sec:real_speedup} si ukáeme merané rıchlosti sériovıch aj paralelnıch verzií oboch algoritmov a vysvetlí 


\chapter{Zrıchlenie}\label{spdup}
V predchádzajúcej kapitole sme popísali dva postupy vıpoètu neznámych derivácií pre splajnové povrchy.
Èasová zloitos oboch algoritmov je rovnaká a síce $O(I\cdot J)$.
Pri urèení asymptotickej èasovej zloitosti zvyèajne zanedbávame rıchlosti jednotlivıch krokov algoritmu ako sú napríklad aritmetické operácie, porovnávanie ve¾kosti èísel, kopírovanie a podobne.
Keï porovnávame rıchlos asymptoticky rovnako rıchlych postupoch musíme bra do úvahy vplyvy jednotlivıch tıchto elementárnych krokov. 
Pochopite¾ne tieto operácie nemusia by rovnako rıchle a môe nasta situácia kedy algoritmus s väèším poètom krokov bude rıchlejší ako inı s menším poètom krokov, ak tieto kroky bude procesor poèítaèa schopnı vykonáva rıchlejšie.

To je práve aj náš prípad. 
Ak u oboch algoritmoch spoèítame všetky aritmetické operácie, tak vısledok bude väèší poèet operácií práve u redukovaného algoritmu.
Pri reálnej implementácií na poèítaèi sa ale ukázalo, e napriek väèšiemu poètu aritmetickıch operácií ako sú sèítanie, násobenie a delenie, je redukovanı algoritmus rıchlejší èo si ukáeme v èasti \ref{sec:theory_speedup}. 
%Redukovanı algoritmus De Boorovej interpolácie obsahuje väèší poèet aritmetickıch operácií ako sú sèítanie a  násobenie, prièom obsahuje menší poèet delení.  
%V èasti \ref{sec:theory_speedup} si ukáeme, e redukovanı algoritmus je skutoène rıchlejší. 
%Tu iba poznamenajme, e zrıchlenie nastáva najmä vïaka zredukovanému poètu delení.
V následujúcej èasti si najprv popíšeme technické parametre procesorov v dôsledku ktorıch dosahujeme zrıchlenie a potom spoèítame poèty aritmetickıch operácií oboch algoritmoch. 
Následne budeme schopní k jednotlivım aritmetickım operáciám v jednotlivıch krokoch priradi \pojem{ceny}, ktoré urèia váhu tıchto krokov a z nich vypoèítame celkové rıchlosti algoritmov a následne zrıchlenie redukovaného spôsobu.

Na modernıch procesoroch v prípade matematickıch operácií s plávajúcou desatinnou èiarkou platí, e sèítanie a násobenie sú podobne rıchle, prièom delenie je nieko¾konásobne pomalšie. 
Pamäové operácie sú pritom v závislosti od konkrétneho typu operaènej pamäte pribline dvadsanásobne pomalšie ako sèítanie, resp. násobenie.\footnote{V praxi sa aj vıpoèty rádovo tisícov uzlov èasto zmestia do vyrovnávacej pamäte procesora (\pojem{cache}). V tom prípade sú pamäové operácie len $1\times$-$10\times$ pomalšie ako sèítanie.}  

\section{Procesorová architektúra}

Predtım ako zaèneme s poèítaním operácií je nutné objasni si ako moderné procesory narábajú s dátami a ako funguje aplikovanie vıpoètov.
Architektúry CPU prešli za posledné desaroèia znaènım vıvojom. 
V dnešnej dobe u nemono zvyšova vıpoètovú rıchlos hrubou silou zvyšovaním frekvencie. 
Moderné procesorové mikroarchitektúry èasto pouívajú rôzne optimalizaèné \uv{triky a finty} ako dosiahnu zlepšenie vıkonu a ktoré majú znaènı vplyv na reálne rıchlosti programov a algoritmov. 
Dvomi takımi optimalizáciami sú takzvané kešovanie a inštrukènı paralelizmus.    

\subsection{Kešovanie}\label{sec:kesovanie}

Pri návrhu algoritmu je vhodné si uvedomi tvar dátovıch štruktúr do ktorıch pri reálnej implementácií budeme uklada funkèné hodnoty, uzly a derivácie.
Naša implementácia v prípade kriviek pouíva klasické vektory, teda polia. 
Pri povrchoch sa hodnoty reprezentujú maticami. 
Maticu je moné interpretova buï ako \uv{pole polí} respektíve \uv{vektor vektorov} (anglicky \uv{jagged array}), alebo ako jedno spojité pole, kde prvok na $i$-tom riadku a $j$-tom ståpci má v takejto reprezentácii index $n\cdot i+j$, kde $n$ je poèet ståpcov.  My budeme  v meraniach a vıpoètoch uvaova práve prvú reprezentáciu znázornenú na obrázku nišie.
\obrazok{jarr.png}{0.407}{Vizuálna reprezentácia dátovej štruktúry \uv{pole polí}.\label{obr:jagged_array}}

Operaèná pamä v dnešnıch poèítaèoch je rádovo pomalšia ako procesor, ktorı musí èaka desiatky a stovky strojovıch cyklov ak chce naèíta hodnotu z pamäte. 
Moderné procesory preto pouívajú systém malıch, ale rıchlych vyrovnávacích pamätí tzv. \textit{cache} do ktorıch sa prednaèítavajú dáta a strojové inštrukcie programu z operaènej pamäte, v ideálnom prípade skôr ako ich procesor bude potrebova. 
Toto kešovanie je plne automatickı proces riadenı samotnım CPU. 
Programátor má len nepriame monosti ovplyvnenia tohto procesu, napríklad vhodnım vıberom dátovıch štruktúr a podobne. 

Uvaujme maticu $m \times n$ typu pole polí ako z obrázka vyššie. 
Ak z matice naèítame prvok $a_{0,0}$ tak je vysoko pravdepodobné, e procesor následne bude ma nakešované aj prvky $a_{0,1}$, $a_{0,2}$ pretoe sú z jedného po¾a a teda sú v pamäti \uv{ved¾a seba} (CPU kešuje pamä po spojitıch blokoch), ale u nemusí ma kešovanı prvok $a_{1,0}$ lebo tento je u z iného po¾a a teda z úplne inej oblasti pamäte. 
Z toho v praxi vyplıva, e vıraz $a_{0,0} + a_{0,1}$ procesor vyhodnotí rıchlejšie ako vıraz $a_{0,0} + a_{1,0}$ pretoe v prvom prípade má obe hodnoty vo vyrovnávacej pamäti. 

Pozornı èitate¾ si môe všimnú, e v prípade pouitia druhej reprezentácie matice, teda jedného ve¾kého spojitého po¾a dåky $m \cdot n$ by sa zvıšila pravdepodobnos kešovania aj prvku $a_{1,0}$.
V tomto prípade sa toti bude nachádza v tom istom bloku pamäte ako prvok $a_{0,0}$ iba o $n$ prvkov (t.j. jeden celı ståpec) ïalej. 
Toto je pravda a všeobecne sa druhá menovaná reprezentácia povauje za efektívnejšiu vzh¾adom na procesorovı èas a pamä poèítaèa, ale to platí len pre malé matice najmä s malım poètom ståpcov $n$.

V aplikácii sme toti vyskúšali obe varianty reprezentácie a pre matice s rádovo $1000 \times 1000$ prvkami sa ako efektívnejšia ukazuje práve prvá reprezentácia, teda \uv{pole polí}. 
Toti ak jeden prvok matice má $8$ bajtov (ve¾kos èíselného typu \textit{double} vo väèšine jazykoch), tak matica zaberá v pamäti pribline $7\text{,}63$ mebibajtov. 
Pri matici typu pole polí máme $1000$ polí kadé zaberajúce práve $7\text{,}81$ kibibajtov ($1$ KiB = $2^{10}$ B = $1024$ B, $1$ MiB = $2^{10}$  KiB, atï.). 
Pre CPU je kešovanie takıchto polí podstatne jednoduchšie ako v prípade matice reprezentovanej jednım po¾om, ktoré samotné má ve¾kos práve $7\text{,}63$ MiB, èo presahuje kapacitu väèšiny vyrovnávacích pamätí.
Obrázok \ref{img:cacheSpeed} nišie názorne ukazuje vzah medzi ve¾kosou dátovej štruktúry v KiB a poètom strojovıch cyklov, ktoré procesor musí èaka pre prístup k jej prvkom. 
Ako vidie do pri dosiahnutí ve¾kosti $32$ KiB, dáta sú namiesto ve¾mi rıchlej vyrovnávacej pamäte L1 kešované do trojnásobne pomalšej vyrovnávacej pamäte L2 atï..
\newpage
\obrazok{cacheIntel.png}{0.6}{Graf rıchlosti prístupu k dátam rôznych ve¾kostí na modernıch CPU\cite{cacheIntel}.\label{img:cacheSpeed}}

\subsection{Inštrukènı paralelizmus}\label{sec:instrukcny_paralelizmus}
V poslednıch rokoch sa v poèítaèovej vede stále viac spomína pojem paralelizmu. 
Dnešné procesory architektúry x86 vyuívajú a štyri úrovne paralelizácie vıpoètov. 
Na najvyššej úrovni hovoríme o návrhu kedy je procesor zloenı z nieko¾kıch autonómne pracujúcich \uv{podprocesorov} nazıvanıch \pojem{jadrá}. 
Tie zdie¾ajú systémové zbernice a pamä prièom majú väèšinou vlastnú L1 alebo L2 cache. 
Kadé jadro môe spracováva na sebe nezávislé procesy prípadne jeden proces môe by rozdelenı do takzvanıch vlákien, kde kadé môe by spracovávané inım jadrom. 
V tomto prípade hovoríme o takzvanom \pojem{vláknovom paralelizme} s ktorım sa stretávame najmä pri programovaní vo vyšších jazykoch ako sú C, Java, Haskell a iné. 

\begin{pozn}
V našej implementácii testujeme vláknovo paralelizované aj klasické sériové verzie algoritmov.
Princíp paralelizovanej verzie sme struène popísali na konci èasti \ref{sec:red_deboor}.
\end{pozn}

Ïalšie úrovne paralelizácie majú spoloèné oznaèenie \pojem{inštrukènı paralelizmus}. 
Pod tımto pojmom rozumieme \pojem{superskalárnos}, \pojem{pipelining} a \pojem{vektorizáciu}. 
Pri tejto úrovni paralelizmu má programátor len obmedzené monosti jeho ovplyvnenia, všetku \uv{akú} prácu obstará prekladaè a pri behu aplikácie zasa inštrukènı plánovaè v samotnom procesorovom jadre. 

Hlavnı vplyv na vıkon plného a najmä redukovaného algoritmu má superskalárnos. 
Vysvetlime èo tento pojem znamená. 
Kadé z procesorové jadier je tvorené nieko¾kımi a desiatkami špecializovanımi jednotkami ako sú aritmeticko logické jednotky (ALU), bitové posuvníky (Shift), numerické koprocesory (FPU) a podobne.
Narozdiel od celıch jadier, tieto jednotky vo všeobecnosti nedokáu fungova samostatne a simultánne spracováva viacero vlákien alebo procesov\footnote{Existujú technológie ako napríklad Hyper-threading umoòujúce za urèitıch podmienok uplatni vláknovı paralelizmus aj v rámci jediného superskalárneho jadra.}. 
Vedia iba v rámci jedného vlákna, za splnenia urèitıch podmienok, spracováva nieko¾ko inštrukcií jediného procesu (vlákna) naraz. 
Nutnou podmienkou je napríklad vzájomná nezávislos nieko¾kıch po sebe idúcich inštrukcií, teda keï vısledok jednej inštrukcie nezávisí na vısledku predchádzajúcej.

Tu ale paralelizácia nekonèí. 
Aj samotné jednotky toti dokáu simultánne spracováva viac ne jeden dátovı vstup. 
Na tejto úrovni rozlišujeme medzi vektorizáciou, a pipeliningom. 
Prvá menovaná technika umoòuje jednu inštrukciu aplikova na celé vektory, resp. polia. 
Vektorizáciu vieme poui ak vykonávame operácie na vektore tak, e vıpoèet $i$-teho prvku nezávisí na vısledku vıpoètu (napr.) $(i-1)$-teho prvku.
V algoritme \ref{alg:SolveLU} pre LU dekompozíciu môeme vidie, e toto neplatí. 
Vektorizácia nás teda nemusí zaujíma.

Pipelining je zaloenı na myšlienke princípu fungovania vıpoètovıch jednotiek podobne ako vırobná linka vo fabrike, kde novı vırobok na linku vstúpi skôr ako je predchádzajúci dokonèenı \cite{pipelining}. 
Teda aj väèšina vıpoètovıch jednotiek dokáe s novım vıpoètom zaèa ešte pred dokonèením práve prebiehajúcej operácie.
Táto technika sa prejavuje najviac ak máme ve¾kı poèet operácií rovnakého typu, ktoré sú navyše na sebe nezávislé podobne ako pri vektorizácii.
To opä nie je prípad našich algoritmov take ho zanedbáme.

\begin{pozn}
	Aby som neuviedol èitate¾a v omyl, svoje závery oh¾adom vektorizácie a pipeliningu upresním.
	Procesor pri vykonávaní algoritmu robí mnoho operácií nevıpoètového charakteru, ktoré sú programátorovi skryté a kde sa môu (nielen) tieto techniky prejavi. 
	Ale aj po zanedbaní dostávame korešpondujúce vısledky meraní a vypoèítaného zrıchlenia, ktoré sa líšia najviac o jednu desatinu.
	Uvaovaním vplyvu tıchto techník pri poèítaní zrıchlenia by sa dosiahnutı cie¾ a síce vysvetlenie príèin urıchlenia redukovaného algoritmu nezmenil.
	Teda vzh¾adom na mnostvo potenciálne investovaného èasu by nezanedbanie tıchto techník bolo kontraproduktívne. 
\end{pozn}

\obrazok{skylakeCore.png}{0.6}{Schéma vıpoètového jadra mikroarchitektúry Intel Skylake \cite{intelOpt}. \label{obr:skylakeCore}}

Spomenuli sme majoritnı vplyv superskalárnosti. 
Na obrázku \ref{obr:skylakeCore} vidíme schému jedného jadra procesorovej mikroarchitektúry Intel Skylake, ktorá je ku dòu písania práce najmodernejšou bene dostupnou procesorovou generáciou a na ktorej testujeme zrıchlenie redukovaného algoritmu. 
Jadrá (nielen) tejto architektúry sú vybavené dvomi sèítaèko-násobièkami èísiel s plávajúcou desatinnou èiarkou, ktoré sú na obrázku zvıraznené èervenou farbou. 
Pointa superskalárnosti v tomto prípade spoèíva v monosti vıpoèty vırazov typu $a_0\circ a_1\circ\dots\circ a_n$, kde $\circ \in \{+, \cdot\}$ rozloi medzi dve jednotky a dosiahnu dvojnásobného zrıchlenia. 
Toto má znaènı vplyv na rıchlos redukovaného algoritmu najmä pri poèítaní pravıch strán trojdiagonálnych rovníc, ktoré sú u na prvı poh¾ad zloitejšie ako v prípade plného algoritmu. 
Keïe procesor má ale iba jednu delièku, pre vırazy typu $a_0 / a_1 /\dots / a_n$ takıto trik fungova nebude.

Procesorové jadro na obrázku vyššie má svojich 29 jednotiek prístupnıch cez osem zberníc (porty 0 a 7). To konkrétne v prípade procesorov Skylake znamená, e dokáu naraz vyuíva maximálne osem svojich vıpoètovıch jednotiek za splnenia urèitıch podmienok. 
Málokedy ale proces alebo vlákno obsahuje vdy osmice vzájomne nezávislıch inštrukcií. 
V situácií kedy jeden proces (vlákno) nemôe vyui všetky porty jadra, niektoré procesory umoòujú nevyuité porty priradi inému procesu (vláknu). 
Táto technika sa nazıva \pojem{Simultaneous Multi-Threading} (ïalej len SMT). 
V literatúre sa, v prípade procesoroch Intelu, èasto môeme stretnú s názvom \pojem{Hyper-Threading}. 
Procesory AMD majú implementovanı odlišnı variant tejto techniky zvanı \pojem{Clustered Multi-Threading}. 
Tu namiesto klasickıch jadier je procesor vybavenı tzv. modulmi, kde kadı modul má dve samostatné \uv{oklieštené} jadrá schopné spracováva iba celoèíselné operácie a jedinú FPU jednotku spoloènú pre oba jadrá. 
V praxi teda SMT predstavuje akısi medzistupeò medzi vláknovım a inštrukènım paralelizmom, 
kedy procesor operaènému systému a beiacim procesom hlási väèší poèet jadier akım je v skutoènosti vybavenı, prièom interne na úrovni mikroarchitektúry sa jedná iba o ïalšiu techniku superskalárnosti.

SMT má vırazne pozitívny vplyv na vıkon procesora ak procesy (vlákna) zdie¾ajúce jedno jadro nepoadujú prístup k tım istım jednotkám. 
V opaènom prípade dochádza k javu kedy jeden proces (vlákno) musí èaka na uvo¾nenie jednotky druhım procesom (vláknom) a vtedy môe dôjs k zníeniu vıkonu oproti identickému procesoru s neaktívnym SMT.
Trocha predbehnime a priamo uveïme, e v praktickıch meraniach má SMT na vláknovo paralelnú verziu redukovaného algoritmu negatívny vplyv, èo si vysvetlíme v èasti \ref{sec:real_speedup}. 
 

\subsection{Rıchlos aritmetickıch operácií}\label{sec:instr_rychlost}
Procesory majú mnoho aritmetickıch jednotiek špecializovanıch na urèitı typ operácie. 
Je prirodzené predpoklada, e tieto jednotky budú pracova navzájom rozliènımi rıchlosami. 
V prípade vıpoètovıch algoritmov má vplyv na rıchlos, pochopite¾ne okrem vıberu vhodnıch dátovıch štruktúr, najmä doba vykonania základnıch matematickıch operácií a síce sèítania, odèítania, násobenia a delenia. 

Najlepším zdrojom ako zisti rıchlos tıchto operácií je dokumentácia inštrukènıch sád procesorov.
Inštrukèná sada x86 sa od svojho prvotného uvedenia v roku 1978 doèkala mnohıch rozšírení. 
Moderné procesory obsahujú nieko¾ko spôsobov ako napríklad vynásobi dve èísla. 
Keïe nie je v silách otestova všetky moné rozšírenia sady, zvolili sme si jedno konkrétne rozšírenie a síce Streaming SIMD Extensions (skrátene SSE), konkrétne vo verzii 4 (SSE4). 
Sady z rodiny SSE sú v èase písania práce najpouívanejšími sadami (najmä verzia SSE2) ktoré sú podporované prakticky všetkımi procesormi od roku 2003. 

V súèasnosti u existuje modernejšia náhrada tejto sady zvaná Advanced Vector Extensions (skratka AVX), ktorej hlavnı prínos spoèíva vo vylepšenıch vektorovıch operáciach. 
Vektorové operácie však vyadujú aby vıpoèty vyuívajúce jednotlivé prvky vektora boli navzájom nezávislé. 
To nie je prípad ani jedného z testovanıch algoritmov. 
Nakonfigurovaním prekladaèa na generovanie tıchto inštrukcí by sme iba znemonili beh aplikácie na polovici z testovanıch procesorov. 
Praktické zrıchlenie sme testovali na šiestich procesoroch architektúry x86, prièom sme pokryli väèšinu mikroarchitektúr v rozmedzí rokoch 2007 a 2015.

V následujúcej tabu¾ke \ref{tab:instr_speed} uvidíme rıchlosti štyroch základnıch matematickıch operácií v rámci šiestich testovanıch mikroarchitektúr. 
Tabu¾ka obashuje tieto ståpce.
\begin{itemize}
	\item \textbf{Architektúra (rok)}\newline
	Testovaná mikroarchitektúra a rok jej uvedenia na trh. 
	Architektúry sú zoradené abecedne pod¾a vırobcu a následne pod¾a roku vydania.
%	\item \textbf{Operácia}\newline
%	Symbol pre príslušnú skalárnu aritmetickú operáciu na 64 bitovıch èíselnıch typoch s pohyblivou desatinnou èiarkou inštrukènıch sadách SSE a SSE4.
	\item \textbf{Odozva}\newline
	Poèet strojovıch cyklov potrebnıch na vykonanie inštrukcie.
	\item \textbf{Inverznı prietok}\newline
	Poèet strojovıch cyklov ktoré je nutné èaka kım je daná vıpoètová jednotka schopná zopakova inštrukciu. 
	V prípade operácií sèítania, odèítania a násobenia je tento poèet menší ako odozva. 
	To znamená, e aritmetické sèítaèky a násobièky sú schopné, vïaka technike pipelining-u, zaèa novı vıpoèet ešte pred dokonèením aktuálnehu vıpoètu.
\end{itemize}

\footnotetext{\label{footnote:round_divisor}Odozva je nadobúda menšie hodnoty ak je delite¾ celı.}
Pod¾a tabu¾ky vidno, e operácie sèítania a odèítania sú rovnako rıchle èo sa pochopite¾ne dalo oèakáva. 
Tieto dve operácie preto budeme spoloène oznaèova symbolom $\pm$. 
Od tejto chvíle ak spomenieme operáciu sèítania tak tım budeme súèasne myslie aj operáciu odèítania. 
Ako vidie zïaleka najpomalšie je práve delenie.

\begin{table}[h]
\begin{center}
 	\small
 	\begin{tabular}{l|cccc|cccc}	
 		\toprule
 		& \multicolumn{4}{c|}{Odozva}  & \multicolumn{4}{c}{Inverznı prietok} \\
 		Architektúra (rok)
 		& $+$ & $-$ & $\times$ & $\div$ & $+$ & $-$ & $\times$ & $\div$ \\
 		\midrule
 		AMD Piledriver (2012)
 		& 5-6 & 5-6 & 5-6 & 9-27 & 0,5 & 0,5 & 0,5 & 5-10 	\\
 		%\hdashline		
 		Intel Penryn (2007)
 		& 3 & 3 & 5 & 6-21\footref{footnote:round_divisor} & 1 & 1 & 1 & 5-20\footref{footnote:round_divisor}	\\
 		Intel Nehalem (2008)
	 	& 3 & 3 & 5 & 7-22 & 1 & 1 & 1 & 7-22 	\\
 		Intel Sandy Bridge (2011)
 		& 3 & 3 & 5 & 10-22 & 1 & 1 & 1 & 10-22 	\\
 		Intel Haswell (2013)
 		& 3 & 3 & 5 & 10-20 & 1 & 1 & 0,5 & 8-14 	\\
 		Intel Skylake (2015)
	 	& 4 & 4 & 4 & 13-14 & 0,5 & 0,5 & 0,5 & 4 	\\
	 	\bottomrule
 	\end{tabular}
\end{center}
\caption{Tabu¾ka aritmetickıch operácií na rôznych mikroarchitektúrach pod¾a \cite{instrTables}. Údaje predstavujú poèet strojovıch cyklov.}
\label{tab:instr_speed}
\end{table}
%\pozn{
%	 Všetky procesory majú identickú rıchlos sèítania a odèítania, preto budeme tieto dve operácie spoloène oznaèova symbolom $+$. Od tejto chvíle ak spomenieme operáciu sèítania tak tım budeme súèasne myslie aj operáciu odèítania. 
%}

Pre zaujímavos si v tabu¾ke \ref{real_op_speed} nišie ukáme praktické vısledky z testovacej aplikácie. 
Operácie sme merali  o na 512 prvkovom poli, prièom aby sme dostali \uv{rozumne} dlhé èasy vıpoèty boli opakované 500000 krát.
Operácie boli v tvare $a[i] = a[i] \circ a[i-1]$, kde $\circ \in \{+, \cdot, \div\}$. 
Ïalej budeme mera aj pamäovú operáciu kopírovania, prièom rozlišujeme medzi kopírovaním spojitıch ($\rightY$) a nespojitıch ($\righttherefore$) dát.
Kopírovanie v implementácii algoritmov pouívame pri zapísaní vypoèítanıch derivácií z LU dekompozície do vıslednej matice, ktorá obsahuje derivácie prislúchajúce k uzlom.
%\newpage
\begin{oznac} \label{oznac:spoj_nespoj_dat_strukt}
Oznaème dve triedy dátovıch štruktúr symbolmi:
\begin{itemize}
	\item
	$\rightY$ oznaèuje spojité dátové štruktúry ako napríklad vektory.
	\item 
	$\righttherefore$  oznaèuje nespojité dátové štruktúry ako napríklad spájané zoznamy alebo vektory referencií na konkrétne dáta.
	Taktie oznaèuje aj spojité vektory ak operácia kopírovania z jedného vektora do druhého nie je vykonávaná spojite (napr. kopírujeme iba prvky na nepárnych indexoch).
\end{itemize} 
\end{oznac}

V tabu¾ke \ref{real_op_speed} sú namiesto mikroarchitektúr uvedené konkrétne modely procesorov, prièom ich poradie zodpovedá poradiu z minulej tabu¾ky. 

\begin{table}[h]
\begin{center}
	\begin{tabular}{lccccc}	
		\toprule
		Procesor
		& $\pm$ & $\times$ & $\div$ & $\rightY$ & $\righttherefore$\\
		\midrule
		AMD FX-6300
		& 247 & 236 & 445 & 10,3 & 204 \\
		Intel Core 2 Duo E8200 
		& 204 & 261 & 417 & 7,66 & 158 \\
		Intel Core i5 650
		& 857 & 927 & 928 & 9,1 & 130,9 \\
		Intel Core i3 2350M
		& 261 & 362 & 894 & 11,5 & 175 \\	
		Intel Core i5 4440
		& 175 & 243 & 573 & 5,41 & 83,8 \\
		Intel Core i7 6700K
		& 77 & 80 & 147 & 3,5 & 68 \\
		\bottomrule
9	\end{tabular}
\end{center}
\caption{Rıchlos aritmetickıch operácií na konkrétnych CPU. Údaje sú v milisekundách.}
\label{real_op_speed}	
\end{table}

V praxi vidno, e sèítavanie a násobenie môeme povaova za podobne rıchle operácie. 
Je nutné podotknú, e pomery rıchlosti operácií sú závislé od povahy testovania. %, ako sú ve¾kos dátovıch štruktúr, ïalej záv
My sme doby trvania aritmetickıch operandov $\circ \in \{+, \cdot, \div\}$ merali na jednom vektore, prièom testy boli v tvare $a[i] = a[i] \circ a[i-1]$, teda vıpoèet $i$-teho prvku závisel od vısledku vıpoètu predchádzajúceho $(i-1)$-teho prvku.
Tımto sme sa snaili povahu testu èo najviac napodobni tvaru vıpoètov v interpolaènıch algoritmoch.

\pozn{
V prípade, ak by test bol v tvare $a[i] = b[i] \circ c[i]$, tak vıpoèty pre jednotlivé $i$ by boli na sebe nezávislé. 
To by procesoru umonilo poui techniku pipeliningu, prièom pomery èasov násobenia a sèítania by vyšli, vïaka väèšiemu prietoku tıchto dvoch operácií oproti deleniu, násobne väèšie.
Jednak by takıto test nesúhlasil s tvarom vıpoètov v testovanıch algoritmoch a taktie by nekorešpondovalo teoretické zrıchlenie s meranım zrıchlením. 
}

Ešte ostáva ukáza reálny vplyv inštrukèného paralelizmu. V následujúcej tabu¾ke sú uvedené namerané násobky èasov trvania vyhodnotenia vırazu vzh¾adom na poèet operácií špeciálne pre procesor Intel Core i7 6700K.

%\begin{table}[h]
%	\begin{center}
%		\begin{tabular}{rcccccccccc}	
%			\toprule
%			& \multicolumn{10}{c}{Poèet operácií} \\
%			Operácia
%			& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
%			\midrule
%			$\pm$
%			& 77 & 124 & 166 & 200 & 233 & 264 & 296 & 327 & 360 & 393 \\
%			$\times$ 
%			& 80 & 129 & 172,8 & 208 & 242 & 276 & 309 & 342 & 375 & 409 \\
%			$\div$
%			& 147 & 294 & 441 & 588 & 735 & 882 & 1029 & 1176 & 1323 & 1470\\
%			\bottomrule
%		\end{tabular}
%	\end{center}
%	\caption{Rıchlos vyhodnotenia matematickıch vırazov vzh¾adom na poèet aritmetickıch operácií pre procesor Intel Core i7 6700K. Údaje sú v milisekundách.}
%	\label{real_instrpar_ratio_6700k}	
%\end{table


\begin{table}[h]
	\begin{center}
		\begin{tabular}{rccccccccc}	
			\toprule
			& \multicolumn{9}{c}{Poèet operácií} \\
			Operácia
			& 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
			\midrule
			$\pm$
			& 1,61 & 2,15 & 2,59 & 3,03 & 3,43 & 3,85 & 4,25 & 4,68 & 5,11 \\
			$\times$ 
			& 1,61 & 2,16 & 2,6 & 3,04 & 3,45 & 3,86 & 4,27 & 4,69 & 5,11 \\
			$\div$
			& 2 & 3 & 4,01 & 5,01 & 6,02 & 7,02 & 8,03 & 9,03 & 10,04\\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Násobky doby vyhodnotenia vyhodnotenia matematickıch vırazov vzh¾adom na poèet aritmetickıch operácií pre procesor Intel Core i7 6700K.}
	\label{real_instrpar_ratio_6700k}	
\end{table}

Pod¾a tabu¾ky \ref{real_instrpar_ratio} môeme poveda, e ak $t$ je doba vyhodnotenia vırazu s jedinou operáciou sèítania alebo násobenia tak vïaka inštrukènému paralelizmu doba vyhodnotenia vırazu s $n$ operáciami konverguje k $\rfrac{1}{2}\cdot tn$. To neplatí pre delenie, kde doba vyhodnotenia rastie lineárne s rastúcim poètom operácií. 

Pre všetky procesory si struène uvedieme vısledky meraní pre vırazy obsahujúce desa operácií. 

\begin{table}[h]
	\begin{center}
		\begin{tabular}{lccc}
			\toprule
%			& \multicolumn{3}{c|}{2} & \multicolumn{3}{c|}{10} \\
			Procesor
			& $\pm$ & $\times$ & $\div$ \\
			\midrule
			FX-6300 \tiny{3C/6T}
			& & & \\
			C2D E8200 \tiny{2C/2T}
			& & & \\
			Ci5 650 \tiny{2C/4T}
			& 3,84 & 5,31 & 10,03 \\
			Ci3 2350M \tiny{2C/4T}
			& 5,1 & 5,93 & 9,99 \\	
			Ci5 4440 \tiny{4C/4T}
			& & & \\
			Ci7 6700K \tiny{4C/8T}
			& 5,09 & 5,11 & 10,04 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Násobok doby vyhodnotenia matematickıch vırazov obsahujúcich desa operácií daného typu oproti vırazom obsahujúcim iba jednu operáciu.}
	\label{real_instrpar_ratio}
\end{table}


\pozn{
Keïe vıpoètové jadrá kadej testovanej mikroarchitektúry sú vybavené práve dvomi numerickımi koprocesormi (FPU) tak tento jav platí aj pre ne. Napríklad pre mikroarchitektúru Intel Sandy Bridge je vyhodnotenie vırazu s desiatimi operáciami sèítania 5,1-násobne pomalšie ako vyhodnotenie vırazu s jednou operáciu. Analogicky pre násobenie vychádza tento pomer na 5,93 a pre delenie pomer vychádza na 9,99.
V èase písania práce sme nestihli podrobne otestova aj ostatné mikroarchitektúry.  
}

\pozn{
V následujúcich èastiach budeme pre pomer rıchlosti delenia a sèítania namiesto údajov z dokumentácie uvaova nami namerané vısledky, ktoré presnejšie korešpondujú s meranım aj teoretickım zrıchlením redukovaného algoritmu.
%Vïaka tomu, e povaha na nami meranıch syntetickıch vıpoètoch pripomína LU dekompozíciu vykonávanú v oboch algoritmoch, naše testy lepšie korešpondujú s meranım aj teoretickım zrıchlením redukovaného algoritmu. 
}
%Ak $\circ \in \{+, \cdot, \div\}$, tak meranie doby vıpoètu jednotlivıch operácií v tvare $a[i] = a[i+1] \circ a[i]$ vráti úplne iné vısledky ako keby operandy boli z rozliènıch vektor,
%Pre naše potreby sme test implementovali tak aby  pripomínal  
%Delenie bıva a desa násobne pomalšie. 
%To je spôsobné ve¾mi vysokou hodnotou inverzného prietoku v prípade opakovane vykonávanom delení èo nastáva napríklad ak chceme vydeli dva vektory. 
%V prípade našich algoritmov ale dochádza len k jednému deleniu na mnoho sèítaní a násobení. 
%Z toho dôvodu môeme inverznı prietok v prípade delenia zanedba a v kontexte implementovanıch algoritmov delenie povaova pod¾a jeho odozvy za pribline \textbf{trojnásobne} a \textbf{pänásobne} pomalšie ako násobenie. 


\section{Teoretické zrıchlenie}
\label{sec:theory_speedup}
V tejto èasti si spoèítame poèty operácií procedúr tvoriacich plnı a redukovanı algoritmus.
Na základe poznatkov z èasti o procesorovej architektúre si formálne zadefinujme pojmy pre poèty a ceny aritmetickıch operácií ktoré budeme v následujúcich èastiach.

\begin{oznac}
	Mnoinu všetkıch matematickıch vırazov budeme oznaèíme symbolom $\mathbb{V}$.
\end{oznac}

Zadefinujme si funkciu $o$ ktorá vráti poèet aritmetickıch operácií sèítania.

\begin{df}
\label{df:oper_count}
Nech $\mathcal{V}$ je matematickı vıraz obsahujúci $p^\pm$ sèítaní a odèítaní, $p^\times$ násobení, $p^\div$ delení, $p^\rightY$ spojitıch kopírovaní a $p^\righttherefore$ nespojitıch kopírovaní. 
Definujme funkciu $o: \mathbb{V} \to \mathbb{N}^5$ vzahom 
$$o(\mathcal{V}) = \langle p^\pm, p^\times, p^\div, p^\rightY, p^\righttherefore \rangle\text{.}$$
Funkciu $o$ budeme nazıva \pojem{poèet operácií vırazu $\mathcal{V}$}.
\end{df}

\begin{oznac}
Pod¾a èasti \ref{sec:instrukcny_paralelizmus} o inštrukènom paralelizme polome dve premenné, ktoré nám pomôu definova ceny aritmetickıch operácií.
\begin{itemize}
\item
Hodnota $\beta$ znaèí \pojem{faktor inštrukèného paralelizmu} operácií s plávajúcou desatinnou èiarkou.
Inımi slovami hodnota $\beta$ znaèí poèet jednotiek jadra procesora schopnıch poèíta desatinné èísla.
\item
Hodnota $\gamma^\div$ znaèí \pojem{pomer odozvy delenia a sèítania} pri operáciách s plávajúcou desatinnou èiarkou.
Inımi slovami hodnota $\gamma^\div$ znaèí ko¾kokrát je delenie pomalšie oproti sèítaniu.
\item
Hodnota $\gamma^\rightY$ znaèí \pojem{pomer rıchlosti kopírovania a násobenia} pri operáciách s plávajúcou desatinnou èiarkou a spojitıch dátach.
\item
Hodnota $\gamma^\righttherefore$ znaèí \pojem{pomer rıchlosti kopírovania a násobenia} pri operáciách s plávajúcou desatinnou èiarkou a nespojitıch dátach.
\end{itemize}
\end{oznac}

\begin{pozn}
	Pre moderné procesory architektúry x86 budeme pod¾a tabu¾ky \ref{real_instrpar_ratio} uvaova $\beta = 2$. 
	Ïalej pod¾a tabu¾ky \ref{real_op_speed} budeme súhrne uvaova $\gamma^\div = 3$, $\gamma^\rightY = \rfrac{1}{25}$ a $\gamma^\righttherefore = 1$.
\end{pozn}

\begin{pozn}
Faktor inštrukèného paralelizmu $\beta$ budeme uvaova iba pre operácie sèítania a násobenia. 
iadny bene dostupnı procesor toti nedokáe inštrukène paralelizova delenie.
\end{pozn}

Teraz si definujme funkciu $c$ ktorá vráti cenu aritmetickıch operácií pre nejakú matematickú operáciu berúc do úvahy hodnoty $\beta$ a $\gamma^\div$.

\begin{df}
	\label{df:oper_weights}
	Nech $p^\pm$ je poèet sèítaní a odèítaní, $p^\times$ poèet násobení, $p^\div$ poèet delení, $p^\rightY$ poèet spojitıch kopírovaní a $p^\righttherefore$ poèet nespojitıch kopírovaní. 
	Definujme funkcie cien operácií
	\begin{itemize}
		\item 
		$c: \mathbb{N}^5 \to \mathbb{N}^5$ 
		vzahom 
		$$c(\langle p^\pm, p^\times, p^\div, p^\rightY, p^\righttherefore \rangle) = \left\langle \ceil*{\frac{p^\pm}{\beta}}, \ceil*{\frac{p^\times}{\beta}}, \ceil*{\gamma^\div p^\div},  \ceil*{\gamma^\rightY p^\rightY},  \ceil*{\gamma^\righttherefore p^\righttherefore} \right\rangle\text{,}$$
		ktorú nazveme \pojem{cena operácií}.
		\item 
		Nech $V$ je matematickı vıraz a $o(V) = \langle p^\pm, p^\times, p^\div, p^\rightY, p^\righttherefore \rangle$. 
		Potom \pojem{cena operácií vırazu $V$} je funkcia
		$c: \mathbb{V} \to \mathbb{N}^5 \times \mathbb{N}$ 
		v tvare
		$$c(\mathcal{V}) = c(o(\mathcal{V}))\text{.}$$
	\end{itemize}
\end{df} 

V kontexte poèítania operácií a cien budeme z dôvodu zjednodušenia procedúry povaova za mnoiny matematickıch vırazov, prièom algoritmy budeme povaova za mnoiny obsahujúce procedúry a vırazy.
Struène doplòme poèty aj pre procedúry, resp. algoritmy.

\begin{oznac}
	\label{df:oper_count_alg}
%	\begin{itemize}
%		\item 
		Nech $\mathcal{P}$ je procedúra. Funkciu
		$$o(\mathcal{P}) = \sum_{v \in \mathcal{P}} o(v)$$
		nazveme \pojem{poèet operácií procedúry $\mathcal{P}$}.
%		\item 
%		Nech $\mathcal{A}$ je procedúra. Funkciu
%		$$c(\mathcal{A}) = \sum_{x \in \mathcal{A}} c(x)$$
%		nazveme \pojem{poèet operácií algoritmu $\mathcal{A}$}.
%	\end{itemize}
\end{oznac}
Analogicky oznaème aj ceny procedúr, resp. algoritmov.
\begin{oznac}
	\label{df:oper_weights_alg}	
%\begin{itemize}
%	\item 
	Nech $\mathcal{P}$ je procedúra. Funkciu
	$$c(\mathcal{P}) = \sum_{v \in \mathcal{P}} c(v)$$
	nazveme \pojem{cena operácií procedúry $\mathcal{P}$}.
%	\item 
%	Nech $\mathcal{A}$ je procedúra. Funkciu
%	$$c(\mathcal{A}) = \sum_{x \in \mathcal{A}} c(x)$$
%	nazveme \pojem{cena operácií algoritmu $\mathcal{A}$}.
%\end{itemize}
\end{oznac}

Dôvod, preèo je náš redukovanı algoritmus rıchlejší je práve fakt, e pri òom dochádza k znaène menšiemu poètu delení, ktoré je oproti ostatnım trom operáciám vırazne pomalšie. 
Navyše v prípade redukovaného algoritmu sa prejavuje superskalárnos procesora (najmä) pri príprave pravıch strán rovníc pre LU dekompozíciu ako pod¾a \ref{eq:red1}, \ref{eq:red2}, \ref{eq:red3a}, \ref{eq:red3b}, \ref{eq:red4} v èasti \ref{sec:red_deboor} o poèítaní derivácií redukovanım spôsobom.
V ïalšej sekcii sy spoèítame jednotlivé operácie a vypoèítame teoretické zrıchlenie redukovaného algoritmu.
To budeme poèíta tak, e si zadefinujeme \uv{procedúry} ktoré predstavujú jednotlivé èasti algoritmu pod¾a èastí \ref{sec:tridiagonal} o trojdiagonálnej LU dekompozícii, \ref{sec:full_deboor} o plnom algoritme a \ref{sec:red_deboor} o redukovanom algoritme. 

Najprv polome procedúry predstavujúce LU dekompozíciu spoloèné pre oba postupy.
\begin{itemize}
	\item
	Procedúra \textit{InicalizujLU} inicializuje hodnoty pravej strany sústavy rovníc $r_0$, \dots, $r_{K-1}$ a hodnotu $b$ z LU dekompozície pod¾a rovnice \ref{eq:deboorM} v prípade plného algoritmu, respektíve pod¾a rovnice \ref{eq:redM} v prípade redukovaného algoritmu.
	\item
	Procedúra \textit{VyriešLU} vypoèíta sústavu rovníc na základe hodnôt pravej strany poskytnutımi \textit{InicalizujLU}.    
\end{itemize}
Kadı algoritmus inicializuje pravé strany inak, take pre oba si ceny uvedieme osobitne.
\subsection{Cena plného algoritmu}
\label{sec:full_cost}
Ceny základnıch aritmetickıch a pamäovıch operácií pre vyššie uvedené procedúry môeme zhrnú do tabu¾ky, prièom uvaujeme poèty v našej ukákovej implementácii\footnote{Repozitár so zdrojovımi kódmi k aplikáciám mono nájs na adrese https://github.com/vildibald/VKDiplom-master}.
Riadky tabu¾ky predstavujú jednotlivé procedúry a 
ståpce udávajú poèet vykonanıch operácii, kde $K$ je poèet neznámych. 
Podotıkam, e operáciu odèítania budeme uvaova ako sèítanie. 
Operácia $\rightY$ predstavuje spojité kopírovanie vypoèítanıch derivácií do vıslednej matice uzlov.  
Pri meraní sa ukázalo, e kopírovanie spojitıch dát vieme má cenu $0\text{,}04$ teda kopírovanie je $25$ násobne rıchlejšie ako sèítanie alebo násobenie.
V tabu¾kách budeme pre sèítanie, násobenie a delenie uvádza ich ceny pod¾a definície \ref{df:oper_weights}. 

\begin{table}[h]
\begin{center}
	\begin{tabular}{lcccc}		
		\toprule
		%		\diag{.1em}{4cm}{Procedúra}{Operácia}
		Procedúra
		& $\pm$ & $\times$ & $\div$ & $\rightY$ \\
		\midrule
		\textit{InicalizujLU}
		& $K$ & $K$ & $0$ & $0$\\
		\textit{VyriešLU}
		& $3K$ & $2K$ & $\gamma^\div K$ & $\gamma^\rightY K$\\
		\bottomrule
	\end{tabular}
\end{center}
\caption{Ceny operácií LU dekompozície pre plnı algoritmus vzh¾adom na poèet neznámych $K$.}
\label{lu_operations}	
\end{table}

Procedúry \textit{VyriešLU} a \textit{InicalizujLU} neobsahujú matematické vırazy s viac ako jednım sèítaním prípadne násobením. 
Superskalárnos procesora sa teda v prípade plného algoritmu neprejaví.
Uvaujme procedúry predstavujúce implementáciu plného algoritmu pod¾a èasti \ref{sec:full_deboor}:
\begin{itemize}
\item
Procedúra \textit{VypoèítajDx} vypoèíta parciálne derivácie $d^x$ pomocou procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor1}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^x$ pre jeden ståpec. 
Teda procedúra musí poèíta LU pre kadı ståpec, ktorıch je $J$. 
\item
Procedúra \textit{VypoèítajDxy} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor2}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^{xy}$ pre jeden ståpec. 
Procedúra musí poèíta LU pre prvı a poslednı ståpec.
\item
Procedúra \textit{VypoèítajDy} vypoèíta parciálne derivácie $d^y$ pomocou procedúry procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor3}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^y$ pre jeden riadok. 
Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$.
\item
Procedúra \textit{VypoèítajDyx} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúry procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
Vstupné hodnoty vezmeme z \ref{eq:deboor4}. 
Jedno volanie \textit{VyriešLU} vypoèíta derivácie $d^{xy}$ pre jeden riadok. 
Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$.
\item
Procedúra \textit{VypoèítajPlnı} vypoèíta na základe vstupnıch hodnôt pre de Boorovu interpoláciu \ref{eq:deboor_input} zavolaním procedúr \textit{VypoèítajDx}, \textit{VypoèítajDxy}, \textit{VypoèítajDy} a \textit{VypoèítajDyx}.    
\end{itemize}

%V podsekcii \ref{sec:kesovanie} sme odlišovali operácie vykonané na spojitıch vektoroch, t.j. operácie vykonané na ståpcoch matice uzlov a operácie vykonané na riadkoch, kde kadı prvok riadka je z iného vektora a teda aj z inej èasti pamäte pod¾a obrázka \ref{obr:jagged_array}. 
%Kešovanie riadkov znamená kešovanie celej matice uzlov, èo je v prípade ve¾kıch matíc nemoné. 
%Teda operácie na prvkov v riadkoch vo všeobecnosti nemôu by tak efektívne ako v prípade operácií na ståpcoch. 
%Pri našej implementácii, ako bolo spomenuté, na ukladanie uzlov a derivácií pouívame práve dátové štruktúry typu vektor vektorov, prièom derivácie $d^x$ sú poèítané po riadkoch (teda neefektívne)

Nech $I$ znaèí poèet uzlov na osi $x$ a $J$ znaèí poèet uzlov na osi $y$. 
Všetky ceny sú v tvare $a\cdot IJ + b\cdot I + c\cdot J + d$. 
Pre zjednodušenie budeme ceny, tam kde je koeficient $a$ nenulovı, uvádza v tvare $a\cdot IJ$. 
Keïe ceny algoritmov rastú kvadraticky tak pre ve¾ké $I$ a $J$ bude odchılka zanedbate¾ná. 
Pre plnı algoritmus teda dostaneme tieto poèty
\begin{table}[h]
	\begin{center}
		\begin{tabular}{lcccc}			
			\toprule
			Procedúra
			& $\pm$ & $\times$ & $\div$ & $\rightY$ \\
			\midrule
			\textit{VypoèítajDx}
			& $4IJ$ & $3IJ$ & $\gamma^\div IJ$ & $\gamma^\rightY IJ$\\
			\textit{VypoèítajDxy}
			& $8I$ & $6I$ & $2\gamma^\div I$ & $\gamma^\rightY I$\\
			\textit{VypoèítajDy}
			& $4IJ$ & $3IJ$ & $\gamma^\div IJ$ & $\gamma^\rightY IJ$\\
			\textit{VypoèítajDyx}
			& $4IJ$ & $3IJ$ & $\gamma^\div IJ$ & $\gamma^\rightY IJ$\\
%			\textbf{\textit{SUMA}}
%			& $12IJ$ & $9IJ$ & $9IJ$ & $3IJ$\\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Ceny operácií plného algoritmu.}
	\label{full_operations_cached}	
\end{table}

Sèítaním všetkıch cien operácií v tabu¾ke dostaneme následujúci vısledok.

\begin{lema}
\label{lema:full_oper_count}
Nech $I$ a $J$ oznaèujú poèty uzlov na osiach $x$ a $y$. 
Potom sumárna cena operácií plného algoritmu je
\begin{itemize} 
\item
$12IJ$ sèítaní,
\item
$9IJ$ násobení,
\item
$3\gamma^\div IJ$ delení,
\item
$3\gamma^\rightY IJ$ kopírovaní.
\end{itemize}
Cena plného algoritmu teda je
$$21IJ + 3\gamma^\div IJ + 3\gamma^\rightY IJ\textit{.}$$
\end{lema}

\subsection{Cena redukovaného algoritmu}
\label{sec:red_cost}
Redukovanı spôsob na poèítanie derivácií vyuíva inı tvar trojdiagonálej sústavy rovníc. 
Zmeníme teda poèty operácií procedúr \textit{VyriešLU} a \textit{InicalizujLU}. 
Ïalej polome dve nové pomocné procedúry \textit{InicalizujZmiešLU}, ktorá inicializuje hodnoty $r_0$, \dots, $r_{K-1}$ a $b$ z LU dekompozície \ref{eq:LU} pre zmiešané derivácie $d^{xy}$ a k nej príslušnú \textit{VyriešZmiešLU}.

V prípade redukovaného algoritmu nie je kopírovanie vısledku LU dekompozície spojité.
Konkrétne to znamená, e potrebujeme do vektora dåky napríklad $I$ na kadú nepárnu pozíciu uloi hodnotu z vektora $\rfrac{I}{2}$, pretoe LU nám nájde iba polovicu h¾adanıch derivácií.
Cena kopírovania bude pod¾a reálneho merania v závislosti od konkrétneho systému pribline $0\text{,}7$.
Aby sme takéto kopírovanie vizuálne odlíšili od kopírovania v predchádzajúcej èasti, budeme túto operáciu oznaèova symbolom  $\righttherefore$.

\begin{table}[h]
\begin{center}
	\begin{tabular}{lcccc}	
		\toprule
		Procedúra
		& $\pm$ & $\times$ & $\div$ &  $\righttherefore$ \\
		\midrule
		\textit{InicalizujLU}
		& $\rfrac{3}{\beta}K$ & $\rfrac{2}{\beta}K$ & $0$ & $0$\\
		\textit{VyriešLU}
		& $3K$ & $2K$ & $\gamma^\div K$ & $\gamma^\righttherefore K$\\
		\bottomrule
	\end{tabular}
\end{center}
\caption{Ceny operácií LU dekompozície pre redukovanı algoritmus vzh¾adom na poèet neznámych $K$.}
\label{red_lu_operations}	
\end{table}
V prípade inicializovania pravej strany pre LU dekompozíciu v procedúre \textit{InicalizujLU} dochádza k viacerım sèítaniam a/alebo násobeniam v rámci jedného vırazu.
Tu sa následne prejaví superskalárnos vıpoètovıch jednotiek procesorového jadra pod¾a èasti \ref{sec:instrukcny_paralelizmus}.
Moderné procesory architektúry x86 obsahujú práve dve jednotky pre vıpoèty s pohyblivou desatinnou èiarkou èo znamená faktor inštrukèného paralelizmu $\beta = 2$.
To implikuje zaujímavı dôsledok, kedy algoritmus s väèším poètom matematickıch operácií je v praxi rıchlejší ako algoritmus s menším celkovım poètom operácií, ale s viacerımi na sebe závislımi vırazmi (t.j. prípad, keï vıraz $b$ musí by vyhodnotenı a po vıraze $a$).     

%V prípade poètov operácií v procedúrach pre zmiešané derivácie nepristupujeme k niektorım dátam spojito, navyše èítame dáta z nieko¾kıch vektorov naraz èo má malı negatívny vplyv na vıkon. 
%Ten sa pri testovaní ukázal by malı v rozsahu  0\% a 10\% v závislosti od konkrétneho procesora. 
%Aby sa nám to v následujúcej èasti nemılilo tak poèty uvedieme v samostatnıch tabu¾kách kde v prvej budú uvedené len poèty operácií na spojitıch dátach a následne na nespojitıch dátach. 
V prípade zmiešanıch derivácií pouívame odlišné pravé strany rovníc pre LU dekompozíciu.
Osobitne si v tabu¾ke \ref{cross_lu_operations_cached} spoèítajme ceny aj pre tieto procedúry.
\begin{table}[h]
\begin{center}
	\begin{tabular}{lcccc}		
		\toprule
		Procedúra
		& $\pm$ & $\times$ & $\div$ & $\righttherefore$\\
		\midrule
		\textit{InicalizujZmiešLU}
		& $\rfrac{33}{2}K$ & $\rfrac{17}{2}K$ & $0$ & $0$\\
		\textit{VyriešZmiešLU}
		& $3K$ & $2K$ & $\gamma^\div K$ & $\gamma^\righttherefore K$\\
		\bottomrule
	\end{tabular}
\end{center}
\caption{Ceny operácií LU dekompozície pre zmiešané zostatkové derivácie.}
\label{cross_lu_operations_cached}	
\end{table}
Následne analogicky ako v predchádzajúcej sekcii polome procedúry predstavujúce implementáciu redukovaného algoritmu pod¾a èasti \ref{sec:red_deboor}::
\begin{itemize}
	\item
	Procedúra \textit{VypoèítajDxResty} vypoèíta zvyšné parciálne derivácie $d^x$ pod¾a \ref{eq:redr1}.
	\item
	Procedúra \textit{VypoèítajDx} vypoèíta parciálne derivácie $d^x$ pomocou procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red1}. 
	Jedno volanie \textit{VyriešLU} vypoèíta derivácie na párnych riadkoch $d^x$ pre jeden ståpec. 
	Teda procedúra musí poèíta LU pre kadı ståpec, ktorıch je $J$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajResty}.
	\item
	Procedúra \textit{VypoèítajDyResty} vypoèíta zvyšné parciálne derivácie $d^y$ pod¾a \ref{eq:redr2}.
	\item
	Procedúra \textit{VypoèítajDy} vypoèíta parciálne derivácie $d^y$ pomocou procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red2}. 
	Jedno volanie \textit{VyriešLU} vypoèíta derivácie na párnych ståpcoch $d^y$ pre jeden riadok. 
	Teda procedúra musí poèíta LU pre kadı riadok, ktorıch je $I$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajResty}.
	\item
	Procedúra \textit{VypoèítajDxy} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúr \textit{InicalizujLU} a \textit{VyriešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red3a} a \ref{eq:red3b}. 
	Jedno volanie \textit{VyriešLU} vypoèíta na párnych riadkoch(ståpcoch) derivácie $d^{xy}$ pre jeden ståpec(riadok). 
	Procedúra musí poèíta LU pre prvı a poslednı ståpec a pre prvı a poslednı riadok.
	\item
	Procedúra \textit{VypoèítajZmiešResty} vypoèíta zvyšné parciálne derivácie $d^{xy}$ pod¾a \ref{eq:redr4a}, \ref{eq:redr4b} a \ref{eq:redr4c}.
	\item
	Procedúra \textit{VypoèítajDyx} vypoèíta parciálne derivácie $d^{xy}$ pomocou procedúr \textit{InicalizujZmiešLU} a \textit{VyriešZmiešLU}. 
	Vstupné hodnoty vezmeme z \ref{eq:red4}, prièom na ich inicializovanie do LU dekompozície pouijeme práve procedúru \textit{InicalizujZmiešLU}. 
	Jedno volanie \textit{VyriešLU} vypoèíta na párnych ståpcoch $d^{xy}$ pre jeden riadok. 
	Procedúra musí poèíta LU pre kadı párny riadok, ktorıch je $I$. 
	Zvyšné derivácie dopoèítame procedúrou \textit{VypoèítajZmiešResty}.
	\item
	Procedúra \textit{VypoèítajRedukovanı} vypoèíta na základe vstupnıch hodnôt pre de Boorovu interpoláciu \ref{eq:deboor_input} postupnım vykonaním predchádzajúcich siedmich procedúr.    
\end{itemize}
Opä pre zjednodušenie budeme poèty v tvare $a\cdot IJ + b\cdot I + c\cdot J + d$ zanedbáva na $a\cdot IJ$.
Ak hodnota $I$ znaèí poèet uzlov na osi $x$ a hodnota $J$ znaèí poèet uzlov na osi $x$ tak pre redukovanı algoritmus dostaneme  poèty v tabu¾kách \ref{red_operations_cached} a \ref{rest_operations_cached}.
\begin{table}[h]
\begin{center}
	%\begin{tabularx}{\textwidth}{l|cccc}	
	\begin{tabular}{lcccc}	
		\toprule
		Procedúra
		& $\pm$ & $\times$ & $\div$ & $\righttherefore$ \\
		\midrule
		\textit{VypoèítajDx}
		& $\rfrac{3}{2}IJ+\rfrac{3}{2\beta}IJ$ & $1IJ+\rfrac{1}{\beta}IJ$ & $\rfrac{1}{2}\gamma^\div IJ$ & $\rfrac{1}{2}\gamma^\righttherefore IJ$\\
		\textit{VypoèítajDy}
		& $\rfrac{3}{2}IJ+\rfrac{3}{2\beta}IJ$ & $1IJ+\rfrac{1}{\beta}IJ$ & $\rfrac{1}{2}\gamma^\div IJ$ & $\rfrac{1}{2}\gamma^\righttherefore IJ$\\
		\textit{VypoèítajDxy}
		& $8I+8J$ & $6I+6J$ & $2I+2J$ & $\gamma^\rightY I+\gamma^\rightY J$\\
		\textit{VypoèítajDyx}
		& $\rfrac{3}{4}IJ+\rfrac{33}{4\beta}IJ$ & $\rfrac{1}{2}IJ+\rfrac{17}{4\beta}IJ$ & $\rfrac{1}{4}\gamma^\div IJ$ & $\rfrac{1}{2}\gamma^\righttherefore $\\
		\bottomrule
	\end{tabular}
\end{center}	
\caption{Ceny operácií pre derivácie poèítané trojdiagonálnou sústavou.}
\label{red_operations_cached}
\end{table}
\newpage
%Najprv si spoèítajme procedúry pre resty.
\begin{table}[h]
	\begin{center}
		\begin{tabular}{lcccc}	
			\toprule
			Procedúra
			& $\pm$ & $\times$ & $\div$ & $\righttherefore$ \\
			\midrule
			\textit{VypoèítajDxResty}
			& $\rfrac{3}{2\beta}IJ$ & $\rfrac{1}{\beta}IJ$ & $0$ & $0$\\
			\textit{VypoèítajDyResty}
			& $\rfrac{3}{2\beta}IJ$ & $\rfrac{1}{\beta}IJ$ & $0$ & $0$\\
			\textit{VypoèítajZmiešResty}
			& $\rfrac{17}{4\beta}IJ$ & $\rfrac{7}{4\beta}IJ$ & $0$ & $0$\\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Ceny operácií pre zmiešané zostatkové derivácie.}
	\label{rest_operations_cached}	
\end{table}
Sèítaním operácií v predchádzajúcich dvoch tabu¾kách dostaneme následujúci vısledok.

\begin{lema}
	\label{lema:red_oper_count}
	Nech $I$ a $J$ oznaèujú poèty uzlov na osiach $x$ a $y$. 
	Potom sumárna cena redukovaného algoritmu je
	\begin{itemize} 
		\item
		$\rfrac{15}{4}IJ + \rfrac{37}{2\beta}IJ$ sèítaní,
		\item
		$\rfrac{5}{2}IJ + \rfrac{10}{\beta}IJ$ násobení,
		\item
		$\rfrac{5}{4}\gamma^\div IJ$ delení,
		\item
		$\rfrac{3}{2}\gamma^\righttherefore IJ$ kopírovaní.
	\end{itemize}
	Cena redukovaného algoritmu teda je
	$$\rfrac{25}{4}IJ + \rfrac{57}{2\beta}IJ + \rfrac{5}{4}\cdot \gamma^\div IJ + \rfrac{3}{2}\gamma^\righttherefore IJ\textit{.}$$
\end{lema}

\subsection{Pamäové nároky}

Redukovanı algoritmus by nemal by lepší len v poète aritmetickıch operácií, ale taktie prinies menšie pamäové nároky vyplıvajúce z poloviènej ve¾kosti sústav rovníc riešenıch LU dekompozíciou. 
Uvaujme maticu uzlov ve¾kosti $I$ a $J$.
Potrebujeme si pamäta $I\cdot J$ funkènıch hodnôt v uzloch, derivácií pod¾a $x$, $y$ a zmiešanıch derivácií. 
Samotné uzly si pamäta nemusíme lebo uvaujeme len uniformné splajny. 
Teda staèí si nám uloi iba uzly $u_0$, $u_{I-1}$, $v_0$, $v_{J-1}$. 
Zvyšné uzly si vieme vypoèíta vzorcom $u_i =u_0 + |u_{I-1} - u_0|\cdot \frac{i}{I}$ pre ¾ubovo¾né $i$ z $\{1, \dots, I-2\}$, respektíve $v_j =v_0 + |v_{J-1} - v_0|\cdot \frac{j}{J}$ pre ¾ubovo¾né $j$ z $\{1, \dots, J-2\}$. Potrebujeme si teda pamäta aspoò $4\cdot I\cdot J + 4$ èísel pre funkèné hodnoty uzlov.

Poèítanie všeobecnej LU dekompozície pod¾a algoritmu \ref{alg:SolveGeneralLU} potrebuje pä vektorov, kde tri predstavujú trojdiagonálu, jeden pravú stranu, v ktorom na konci bude vısledok.
Nám ale staèí uvaova iba procedúru pre náš špeciálny tvar trojdiagonálnej sústavy pod¾a algoritmu \ref{alg:SolveLU}.
Pri pouití tejto priestorovo optimalizovanej varianty vıpoètu LU dekompozície potrebujeme na vypoèítanie $I\cdot J$ uzlov práve $I\cdot J + 2I + 2J$ pamäte.

\subsection{Zhrnutie}

%Máme všetko pripravené aby sme uviedli náš hlavnı vısledok.
Po spoèítaní cien jednotlivıch matematickıch a pamäovıch operácií v èastiach \ref{sec:full_cost} a \ref{sec:red_cost} pristúpime k formulácii zrıchlenia. 

\begin{veta}
\label{veta:full_red_ratio}
%Nech $I$ a $J$ oznaèujú poèty uzlov na osiach $x$ a $y$.
Oèakávané zrıchlenie redukovaného algoritmu je
$$\frac{21+3\gamma^\div+3\gamma^\rightY}
	{\rfrac{25}{4} + \rfrac{57}{2\beta} + \rfrac{5}{4}\cdot \gamma^\div + \rfrac{3}{2}\gamma^\righttherefore}$$ 
\end{veta}

\begin{dokaz}
Uvaujme mrieku uzlov ve¾kosti $I$ a $J$. 
V lemách \ref{lema:full_oper_count} a \ref{lema:red_oper_count} dostávame ceny 
\begin{itemize}
	\item
	$21IJ + 3\gamma^\div IJ + 3\gamma^\rightY IJ$ pre plnı algoritmus,
	\item
	$\rfrac{25}{4}IJ + \rfrac{57}{2\beta}IJ + \rfrac{5}{4}\cdot \gamma^\div IJ + \rfrac{3}{2}\gamma^\righttherefore IJ$ pre redukovanı algoritmus.
\end{itemize}
Zrıchlenie vyjadríme ako podiel cien oboch algoritmov.
$$\frac{21IJ+3\gamma^\div IJ+3\gamma^\rightY IJ}
{\rfrac{25}{4}IJ + \rfrac{57}{2\beta}IJ + \rfrac{5}{4}\cdot \gamma^\div IJ + \rfrac{3}{2}\gamma^\righttherefore IJ}\textit{.}$$
Ceny algoritmov sme poèítali asymptoticky, t.j. cenu v tvare $a\cdot IJ + b\cdot I + c\cdot J + d$ sme redukovali na tvar $a\cdot IJ$. 
Po vykrátení $IJ$ z vırazu vyššie dostaneme oèakávané zrıchlenie redukovaného algoritmu.  	
\end{dokaz}

Ukáme si dva príklady zrıchlenia aby sme názorne videli vplyv inštrukèného paralelizmu na rıchlos redukovaného algoritmu.
V prvom príklade predpokladajme porovnanie algoritmov na modernom procesore, prièom v druhom uvaujme primitívny procesor. 


\pr{ \label{pr:ratio2}
	Nech $\beta = 2$, teda procesorové jadro má práve dve jednotky pre vıpoèty s pohyblivou desatinnou èiarkou a $\gamma^\div = 3$.
	Ïalej nech $\gamma^\rightY = \rfrac{1}{25}$ a $\gamma^\righttherefore = \rfrac{3}{5}$. 
	Analogicky ako v predchádzajúcom príklade dosadením do vzahu dostaneme
	$$\frac{30\textit{,}12}{25\textit{,}15} \approx 1\textit{,}2\textit{.}$$
	V prípade inštrukèného paralelizmu s faktorom 2 je redukovanı algoritmus o 20\% rıchlejší ako plnı.
}

\pr{ \label{pr:ratio1}
	Nech $\beta = 1$, teda procesorové jadro má iba jednu jednotku pre vıpoèty s pohyblivou desatinnou èiarkou a $\gamma^\div = 3$, to jest operácia delenia je trojnásobne pomalšia ako operácia sèítania pod¾a tabuliek \ref{tab:instr_speed} a \ref{real_op_speed} operácií v èasti \ref{sec:instr_rychlost}. 
	Ïalej nech $\gamma^\rightY = \rfrac{1}{25}$ a $\gamma^\righttherefore = 1$. 
	Dosadením do vzahu z predchádzajúcej vety dostaneme
	$$\frac{30\textit{,}12}{40} \approx 0\textit{,}75\textit{.}$$
	Pomer je menší ako 1 èo znamená, e bez inštrukèného paralelizmu ($\beta = 1$) je redukovanı algoritmus pomalší ako plnı.
}

Pod¾a príkladov vidíme, e rıchlos redukovaného algoritmu je závislá na schopnosti hardvérovej architektúry procesora paralelizova vyhodnotenia aritmetickıch vırazov s viacerımi operandami.
Je otázne nako¾ko by s rastúcim faktorom inštrukèného paralelizmu $\beta$ rástlo zrıchlenie.
Keïe nemáme k dispozícii procesor s vhodnou hardvérovou vıbavou, ktorı by mal viac ako dve jednotky pre vıpoèty s pohyblivou desatinnou èiarkou (ak vôbec takı existuje) je nároèné predpoklada ako by si takıto stroj s redukovanım postupom poradil. 

V následujúcej èasti si ukáeme reálne vısledky a uvidíme èi s nimi vypoèítané zrıchlenie skutoène súhlasí.

\section{Merané zrıchlenie}
\label{sec:real_speedup}
V kapitole \nameref{spdup} sme urèili teoretické zrıchlenie poèítania uzlov, dosiahnute¾né zredukovaním ve¾kosti trojdiagonálnych sústav. 
V tejto èasti si ukáeme reálne vısledky dosiahnuté v ukákovej implementácii. 

Ako bolo spomenuté, testovací program bol implementovanı v jazyku \cpp. 
Softvér obsahuje testy pre sekvenèné aj paralelné poèítanie derivácií pre oba predmetné algoritmy.
Pouitı prekladaè bol Intel \cpp\ Compiler v 64 bitovej verzii nastavenı na generovanie agresívne optimalizovaného binárneho kódu (-O2), prièom vláknovo paralelné verzie algoritmov boli implementované pomocou rozhrania OpenMP.    

Testy boli vykonané na šiestich rôznych poèítaèovıch zostavách, všetky so systémom Windows 7 a 10. 
Testovacie stroje obsahujú rozlièné multivláknové procesory od starého Penryn z roku 2007 a po najmodernejší Skylake z roku 2015 so vzájomne odlišnımi architektúrami a hlavne spôsobmi vykonávania paralelizovanıch procesov. 

%Procesory oznaèené $^\text{SMT}$ sú vybavené nejakou implemetáciou simultánneho multithreadingu.

Ståpec 1 obsahuje modely procesorov zoradenıch pod¾a mikroarchitektúry ako v tabu¾ke \ref{tab:instr_speed}.
Ved¾a názvu modelu CPU sa nachádza údaj tvaru $n$C/$m$T, kde $n$ je poèet fyzickıch jadier procesora a $m$ poèet logickıch jadier. 
V prípade $m > n$ je procesor vybavenı urèitou formou SMT. 
Ståpce 2 a 3 predstavujú èasy behov sériovej verzie pre povrchové splajny.
Ostávajúce ståpce analogicky znázoròujú èasy a pomer paralelnıch verzií implementovanıch pod¾a myšlienky uvedenej na konci èasti \ref{sec:red_deboor}.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{lcccc}
			\toprule
			& \multicolumn{2}{c}{Sériovo} & \multicolumn{2}{c}{Paralelne}  \\
			Procesor
			& Plnı & Redukovanı & Plnı & Redukovanı \\
			\midrule
			FX-6300 \tiny{3C/6T}
			& 81 & 72 & 21 & 17 \\
			C2D E8200 \tiny{2C/2T}
			& 99  & 87 & 51 & 46 \\
			Ci5 650 \tiny{2C/4T}
			& 80 & 76 & 32 & 33 \\
			Ci3 2350M \tiny{2C/4T}
			& 93 & 75 & 41 & 43\\	
			Ci5 4440 \tiny{4C/4T}
			& 58 & 46 & 15 & 13 \\
			Ci7 6700K \tiny{4C/8T}
			& 36 & 30 & 7 & 8 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Reálne merania plného a redukovaného algoritmu na mrieke $1000\times 1000$ uzlov. Údaje sú v milisekundách.}
	\label{real_speedup}
\end{table}

V tabu¾ke \ref{real_vs_theory_speedup} budeme uvaova merané rıchlosti aritmetickıch operácií z tabu¾ky \ref{real_op_speed} v èasti \ref{sec:instr_rychlost}. 
V ståpcoch 2 a 4 máme pomery rıchlostí $\gamma^\div$, $\gamma^\rightY$ a $\gamma^\righttherefore$ aritmetickıch operácií získané pod¾a tabu¾ky \ref{real_op_speed} v èasti \ref{sec:instr_rychlost}.
Ståpec 5 predstavuje teoretické zrıchlenie redukovaného algoritmu vypoèítané pod¾a vety \ref{veta:full_red_ratio} v predchádzajúcej èasti.
Poslednı ståpec 6 predstavuje merané zrıchlenie sériovej verzie redukovaného algoritmu pod¾a predchádzajúcej tabu¾ky.
%\newpage
\begin{table}[h]
	\begin{center}
		\begin{tabular}{lccccc}
			\toprule
			& \multicolumn{3}{c}{Pomery operácií}
			& \multicolumn{2}{c}{Zrıchlenie}  \\
			Procesor
			& $\gamma^\div$ & $\gamma^\rightY$ & $\gamma^\righttherefore$& teoretické & merané \\
			\midrule
			FX-6300 \tiny{3C/6T}
			& 1,89 & 0,04 & 0,82 & 1,12 & 1,13 \\
			C2D E8200 \tiny{2C/2T}
			& 1,08  & 0,01 & 0,15 & 1,09 & 1,14 \\
			Ci5 650 \tiny{2C/4T}
			& 2,04  & 0,04 & 0,77 & 1,13 & 1,05 \\			
			Ci3 2350M \tiny{2C/4T}
			& 3,43 & 0,04 & 0,67 & 1,21 & 1,24 \\	
			Ci5 4440 \tiny{4C/4T}
			& 3,27 & 0,03 & 0,48 & 1,22 & 1,26 \\
			Ci7 6700K \tiny{4C/8T}
			& 2,98 & 0,02 & 0,4 & 1,21 & 1,2 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{Porovnanie teoretického a meraného sériového zrıchlenia na mrieke $1000\times 1000$ uzlov.}
	\label{real_vs_theory_speedup}
\end{table}

Merané zrıchlenie korešponduje s teoretickım zrıchlením v rámci malej odchılky.  
%Na kadom z troch testovacích strojov sú rıchlosti sèítania a násobenia 64 bitovıch èísel s plávajúcou desatinnou èiarkou totoné. V prípade násobenia, respektíve sèítania a delenia vychádza pomer na procesoroch Intel Core i5 a i3 pribline 9.
%Sériová verzia redukovaného algoritmu je o pribline 17\% rıchlejšia ako pôvodnı de Boorov postup èo súhlasí s odhadnutım zlepšením na konci kapitoly \nameref{spdup} v príklade \ref{ratio2}. 
%Tam nám vyšlo 19\% zrıchlenie, kde zbytok prisudzujem vplyvu pamäovıch operácií, ktoré sme vtedy nebrali do úvahy.
%V prípade procesora AMD FX si môeme všimnú anomáliu, kde novı algoritmus je vırazne rıchlejší ne by mal by pod¾a dosiahnutého pomeru rıchlosti násobenia a delenia. 
%Moja terajšia hypotéza k tomuto javu je zaloená na pozorovaní, e AMD FX procesory majú vırazne pomalší pamäovı subsystém vèítane systému rıchlych vyrovnávacích pamätí\cite{cacheAmd} (tzv. \textit{cache}).
%Pamäové operácie sú teda na AMD FX procesore vırazne drahšie ako na Intel Core. 
%Redukovanı algoritmus má menšie priestorové nároky èo znamená menej %pouitıch pamäovıch operácií. 
%Teda na procesore AMD FX má síce zníenie poètu delení menší vplyv na efektivitu redukovaného algoritmu, ale to mohlo by \uv{vyváené} práve zníením poètu, na tomto CPU pomalıch, pamäovıch operácií.
Môeme si všimnú malé škálovanie vıkonu paralelizovaného algoritmu najmä v prípade procesorov Intel obsahujúcich SMT kde je redukovanı algoritmus dokonca o nieèo pomalší ako plnı. 
Túto pomalos sme nedokázali zatia¾ jednoznaène vysvetli, no máme dve moné hypotézy:
\begin{itemize}
\item 
Prvou zmıš¾anou príèinou môe by fakt, e v plnom algoritme všetky parciálne derivácie pod¾a nejakej premennej vypoèítame trojdiagonálnymi sústavami naraz v jednom cykle. 
V redukovanom ale cez trojdiagonálne sústavy vyrátame len polovicu derivácií, prièom zvyšok dopoèítame práve restami. 
Toto rozdelenie vıpoètu na dve subprocedúry môe hypoteticky implikova vysokú réiu plánovaèa vlákien (tzv. \pojem{thread scheduler}) vrstvy OpenMP alebo operaèného systému. 
V implementácií sa nám podarilo spoji vıpoèet restov spolu s LU dekompozíciou do jedného kroku v prípade derivácií pod¾a premennıch $x$ a $y$ a resty tak môeme poèíta súèasne s deriváciami poèítanımi cez LU.
Táto optimalizácia však momentálne nie je moná pri zmiešanıch deriváciách. 
Do budúcna máme rozpracované zefektívnenie vıpoètu zmiešanıch restov, ktoré sa nám ale ešte nepodarilo do práce dokonèi. 
\item
Druhá zmıš¾aná príèina môe tkvie v tom, e v prípade redukovaného algoritmu sa \uv{bije} súèasne SMT a superskalárnos ako dve rôzne techniky inštrukèného paralelizmu.
%V prípade SMT procesorov sa dá pomalos vláknovo paralelnej verzie redukovaného algoritmu, aj keï to nemáme overené, vysvetli samotnou superskalárnosou pod¾a podsekcie \ref{sec:instrukcny_paralelizmus}. 
Dnešné procesorové mikroarchitektúry majú vıpoètové jadrá vybavené práve dvomi matematickımi jednotkami pre operácie s plávajúcou desatinnou èiarkou (oznaèujú sa skratkou FPU). 
V tomto prípade SMT môe teoreticky kadú jednotku prideli inému vláknu. 
Pri redukovanom algoritme ale máme ve¾a operácií v tvare $a_0\circ a_1\circ \dots\circ a_n$, kde $\circ \in \{+, \cdot\}$. 
Optimalizujúci prekladaè môe takıto vıpoèet rozloi do viacerıch strojovıch inštrukcií. 
V tomto prípade dôjde k vyuitiu oboch FPU jadra v rámci jediného vlákna ale napriek tomu SMT na toto jadro priradí aj druhé vlákno ktoré potrebuje poèíta práve na FPU jednotke. 
Teda dôjde k situácií kedy dve vlákna zdie¾ajú spoloèné zdroje, v tomto prípade dve FPU jednotky.
Dôjde tak k zbytoènej réii plánovaèa vlákien èi u na úrovni OS alebo inštrukèného plánovaèa samotného procesora, èo spôsobí pokles vıkonu. Ak je táto hypotéza korektná, tak aj v tomto prípade by bolo potrebné upravi resty pri zmiešanıch deriváciách, aby sa ich vıpoèet dal vykona paralelne v jednom kroku spolu s LU dekompozíciou.
Proti tejto hypotéze hovorí fakt, e na procesoroch mikroarchitektúry AMD Piledriver redukovanı algoritmus dosahuje zrıchlenie napriek tomu, e tento procesor má implementovanú SMT.
Pravda, jedná sa o mierne odlišnú implementáciu oproti Intelu, no inštrukènı plánovaè tohto CPU musí rieši identickı problém dvoch vlákien zdie¾ajúcich spoloèné zdroje.
\end{itemize}

Táto kapitola sa venovala poèítaniu zrıchlenia redukovaného algoritmu vzh¾adom na plnı algoritmus.
Ako sme videli, teoretické zrıchlenie je v súlade s nameranım zrıchlením v závislosti od typu procesora.

\chapter*{Záver}

Podarilo sa nám v prípade rovnomerne rozloenıch uzlov urıchli sériovı vıpoèet derivácií splajnov v uzloch a tie zmenši pamäovú nároènos vıpoètu na polovicu. 
Napriek tomu, e vıslednı redukovanı algoritmus obsahuje viac aritmetickıch operácií je vïaka povahe mikroarchitektúr modernıch procesosov a tie vïaka povahy samotnıch operácií rıchlejší o pribline 20\%.
Prioritou teraz ostáva jednak zovšeobecni redukovanı algoritmus aj pre splajny s nerovnomernımi uzlami a upravi zmiešané zbytkové derivácie aby sme mohli docieli ïalšie zrıchlenie a najmä zefektívni vláknovú paralelizáciu.
%Zlepšenie paralelizácie by v budúcnosti umonilo vıpoèty akcelerova grafickou kartou. 
Vláknovo paralelné poèítanie uzlov redukovanım algoritmom nie je vo všeobecnosti v súèasnosti rıchlejšie ale závisí na spôsobe dosahovania vláknového paralelizmu na konkrétnej procesorovej mikroarchitektúre.
Konkrétne pod¾a nameranıch vısledkov vyplıva skutoènos, e procesory Intelu s implementovanım SMT sú pri paralelnom poèítaní uzlov horšie ako procesory bez tejto technológie. 
Vıhodou ale ostávajú polovièné pamäové nároky èo umoòuje rieši väèšie úlohy a tak rozdeli prácu medzi väèší poèet logickıch procesorov. 
To by v budúcnosti umonilo vıpoèty akcelerova pouitím masívne paralelizovanıch èipoch ako sú napríklad grafické karty. 

\part*{Prílohy}
\chapter*{Implementácia a uívate¾ská príruèka} \label{chapt:impl}

Jednım z naším cie¾om je vytvorenie aplikácií na vizuálne a vıkonnostné porovnávanie splajnov, ktorıch uzly sú poèítané De Boorovim a našim redukovanım algoritmom. 
Grafickú vizualizáciu sme implementovali v Microsoft Silverlight, èo je nástroj na tvorbu webovıch aplikácií spustite¾nıch priamo vo webovom prehliadaèi. 
Samotnı vıvoj aplikácii môe prebieha v ¾ubovo¾nom programovacom jazyku beiacom pod Common Language Runtime (CLR). 
V našom prípade sme siahli po jazyku C\#.

%\begin{center}
%	\includegraphics[scale=0.2]{silverlight.jpg}
%\end{center}
Silverlight je kompatibilnı s väèšinou modernıch webovıch prehliadaèov a operaènıch systémov vèítane Microsoft Windows, Apple OS X a vïaka technológii Moonlight -- open-source implementácii Silverlight-u aj na väèšine Linuxovıch distribúcií.
Framework je moné poui aj na vıvoj off-line aplikácií v operaènıch systémoch Windows Phone, Windows 8 a Windows RT. 

\begin{pozn}
	Naša aplikácia pouíva technológie, ktoré nie sú s Moonlight kompatibilné. 
	V súèasnej dobe teda podporujeme iba MS Windows a Apple OS X.
	Prípadná portácia na GNU/Linux by musela by vo forme off-line desktopovej aplikácie.
\end{pozn}
%\obrazok{apka_spl.png}{0.262}{Ukáka z aplikácie.}
Pretoe CLR znemoòuje korektne porovnáva procesorovı èas a pamäové nároky implementovanıch algoritmov, rozhodli sme sa vıkonnostnı tester oddeli do samostatnej aplikácie implementovanej v natívnom jazyku, konkrétne v \cpp. 

%\obrazok{bench.png}{0.277}{Vıkonnostnı tester.}

\section*{Vizualizácia}
V tejto kapitole si ukáeme struènı návod na pouívanie a testovanie implementovanıch aplikácií. 
Zaènime aplikáciou na grafickú vizualizáciu.
\obrazok{apka.png}{0.262}{Aplikácia po spustení.}

Okno aplikácie sa skladá z troch hlavnıch èastí, ktoré si trocha netradiène prejdeme zdola nahor.
%\begin{figure}%[!htb]
%	
%	 \centering
%		\includegraphics[scale=0.4]{apka_spod.png}
%	\par
%	\centering{\parbox{13cm}{\sl \caption{Panel zadávania splajnu.}}
%\end{figure}
\obrazok{apka_spod.png}{0.4}{Panel zadávania splajnu.\label{apka_spod}}
Na obrázku \ref{apka_spod} vidíme panel, pomocou ktorého môeme na ¾ubovo¾nom intervale a s ¾ubovo¾nım poètom uzlov (v rozumnıch medziach) interpolova zapísanú funkciu dvoch premennıch $x$ a $y$.
Popíšme si jednotlivé ovládacie prvky. 
Textové polia oznaèené \textit{U min}, \textit{U max} a \textit{U knots} (\textit{V min}, \textit{V max} a \textit{V knots}) znaèia interval a poèty uzlov na osi $x$ (osi $y$).
Do spodného textového políèka oznaèené \textit{Expression} môeme napísa takmer ¾ubovo¾nú matematickú funkciu premennıch $x$ a $y$ ktorú si eláme vykresli. 
Vysúvate¾nı zoznam oznaèenı \textit{Function type} umoòuje zvoli typ interpolácie. 
Na vıber máme ponúknuté tri monosti akım spôsobom si eláme interpretova matematickı vıraz v políèku \textit{Expression}.
\begin{itemize}
	\item
	\textit{Direct function} vypoèíta funkèné hodnoty potrebné pre grafickú vizualizáciu priamo z funkcie.
	\item 
	\textit{Bicubic} vypoèíta z funkcie iba funkèné hodnoty v uzloch.
	Zvyšné potrebné body sú získané interpolaènım hermitovım bikubickım splajnom. 
	\item 
	\textit{Biquartic} funguje analogicky ako predchádzajúca poloka. 
	Pouije sa ale bikvartickı splajn.
\end{itemize}
Vysúvate¾nı zoznam oznaèenı \textit{Knots generator} nám, v prípade vıberu vykreslenia funkcie splajnom, umoòuje zvoli plnı (\textit{De Boor}) alebo redukovanı (\textit{Reduced de Boor}) algoritmus.
Tlaèítko \textit{Subtract} umoní vykresli rozdiel medzi aktuálne zadanımi hodnotami a nejakou u vykreslenou funkciou. 
Pomocou posuvníka oznaèenı \textit{Auto color} môeme namiesto automaticky vybranej farby vykresli novú plochu vlastnou farbou.
Nakoniec v pravej èasti okna sa nachádzajú tlaèidlá \textit{Clear} a \textit{Draw}, prièom prvé odstráni všetky vykreslené funkcie a druhé nám vypoèíta a zobrazí funkciu pod¾a aktuálne zadanıch hodnôt. 

\obrazok{apka_stred.png}{0.262}{Hlavné zobrazovacie okná.\label{apka_stred}}
Na obrázku \ref{apka_stred} vidíme dominantnú èas aplikácie a síce zobrazovanie funkciovıch plôch. 
%Obrazovka je rozdelená na tri èasti, kde v najväèšia èast implicitne zobrazuje interpretovanú funkciu a zvyšné dve zobrazujú prvú, respektíve druhú zmiešanú deriváciu funkcie.
V ¾avej èasti okna môeme nájs posuvník na škálovanie osi $z$. 
Na spodnej a pravej strane hlavnej èasti okna sú tlaèidlá reprezentované modrou horizontálnou, respektíve zelenou vertikálnou šípkou. Pri ich draní myšou je moné rotova obrazom v danej osi.

\obrazok{apka_vrch.png}{0.65}{Lišta nástrojov.\label{apka_vrch}}
Poloka \textit{Settings} umonuje prispôsobi grafické vykres¾ovanie splajnov. 
Tieto nastavenia je vhodné upravi najmä pri starších poèítaèoch na dosiahnutie optimálnej plynulosti vykres¾ovania.
V strednej èasti panela máme k dispozícii vysúvate¾nı zoznam vykres¾ovanıch plôch, ktorım ich môeme zvırazòova. 
%V pravej èasti nájdeme tri tlaèidlá, ktoré vycentrujú zobrazovanie splajnu, 
%prípadne jeho prvej alebo druhej zmiešanej derivácie.
\obrazok{apka_spl.png}{0.262}{Vykreslené tri splajnové povrchy.}

\section*{Vıkonnostnı tester}
Teraz si popíšme druhú implementovanú aplikáciu zameranú na ukáku èi skutoène je redukovanı algoritmus rıchlejší.  
\obrazok{bench.png}{0.36}{Vıkonnostnı tester.\label{bench}}
\obrazok{bench_surface.png}{0.36}{Zadanie údajov pre testovanie.\label{bench_surface}}
\obrazok{bench_surface_results.png}{0.36}{Vısledky testu.\label{bench_surface_results}}
Na obrázku \ref{bench} môeme vidie úvodné okno aplikácie, ktoré obsahuje šes poloiek. 
Ich vıznam si teraz vyjasníme.
 \begin{itemize}
 	\item[1.]
 	\textit{Multiplication  vs division benchmark} spustí nieko¾ko variant testovania pomerov rıchlosti operácií sèítania, násobenia a delenia.
 	\item[2.] 
 	\textit{Spline curve benchmark} pomerá èasy vıpoètov derivácií pre krivkovı splajn interpolujúci preddefinovanú funkciu plnım a redukovanım algoritmom. 
 	Pred spustením aplikácie vyaduje postupné zadanie dvoj údajov. 
 	Prvı udáva poèet opakovaní testu pre kadı algoritmus. 
 	Vıslednı pomer vznikne vydelením aritmetickıch priemerov nameranıch èasov pre kadı algoritmus. 
 	Èím je zadané èíslo väèšie, tım je meranie menej náchylné na odchılky. Odporúèa sa zada dvojcifernú hodnotu a potvrdi klávesou \textbf{Enter}. 
 	Druhé zadané èíslo znamená poèet uzlov splajnu. 
 	Odporúèa sa zada rádovo $10^5$ a $10^6$ uzlov.
 	Menší poèet dokáe väèšina modernıch poèítaèov vypoèíta príliš rıchlo aby ten èas dokázala aplikácia rozumne zmera.  
 	\item[3.]
 	\textit{Spline surface benchmark} analogicky ako predchádzajúci test testuje pomer èasov vıpoètu plného a redukovaného algoritmu pre plochy. 
 	Druhı zadanı údaj tentoraz znamená poèet uzlov pre jeden rozmer.
 	Celkovı poèet uzlov je teda štvorec zadanej hodnoty. 
 	Pre väèšinu poèítaèov sa odporúèa zada rádovo $10^2$ a $10^3$ uzlov.
 	\item[4.]
	\textit{Spline surface benchmark (in parallel)} paralelná verzia testu pre plochy vyuívajúca na vıpoèet jednej matice uzlov všetky dostupné logické procesory.
 	\item[B.]
 	\textit{Disable/enable optimized LU} prepne medzi naivnou a optimalizovanou variantou algoritmu pre poèítanie LU dekompozície v testoch 2 a 3. 
 	Test 4 toto nastavenie neovplyvòuje z dôvodu znaènıch pamäovıch nárokov naivnej verzie LU dekompozície
 	(program na väèšine strojov zahltí celú operaènú pamä).
 	\item[Q.]
 	\textit{End program} ako názov napovedá, pri stlaèení tlaèidla \textbf{Q} dôjde k vypnutiu aplikácie.
 \end{itemize}


%
%\bibliography{dp} %berie sa z dp.bib

%\renewcommand{\bibname}{Zoznam pou?itej literat?ry}
\begin{thebibliography}{9}
\bibitem{splines}  David Salomon, Curves and Surfaces for Computer Graphics, Springer, 2006
\bibitem{szabominotorok}  I. Szabó, L. Miòo, C. Török, Biquartic polynomials in bicubic spline construction, Central European Journal of Computer Science, accepted for publication (2015)
\bibitem{minoTorok} L. Miòo, C. Török, Fast algorith for spline surfaces, Communication of the Joint Institute for Nuclear Research, Dubna, 2015, E11-2015-77
%\bibitem{lukasRigorozka}  Lukáš Miòo, Parametrické modelovanie dát komplexnej štruktúry, PF UPJŠ, 2014
\bibitem{deboor}  C. de Boor, Bicubic spline interpolation, Journal of Mathematics and Physics, 41(3),1962, 212-218.
%\bibitem{csharp}  J. Albahari, B.Albahari, C\# 5.0 in a Nutshell, O'Reilly, 2012
\bibitem{her_nat} E. S\"{u}li, D. Mayers, An Introduction to Numerical Analysis, Cambridge University Press, 2003, ISBN 0 521 00794 1
\bibitem{app}  https://github.com/vildibald/VKDiplom-master, repozitár so zdrojovımi kódmi k aplikáciám.
\bibitem{lu_c} https://en.wikibooks.org/wiki/Algorithm\_Implementation/Linear\_Algebra/Tridiagonal\_matrix\_algorithm
\bibitem{cacheIntel} http://www.anandtech.com/show/9483/intel-skylake-review-6700k-6600k-ddr4-ddr3-ipc-6th-generation/9
\bibitem{intelOpt} http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf
\bibitem{instrTables} http://www.agner.org/optimize/instruction\_tables.pdf
\bibitem{pipelining} http://www.lighterra.com/papers/modernmicroprocessors/
%\bibitem{cacheAmd} http://techreport.com/review/23750/amd-fx-8350-processor-reviewed/3
\end{thebibliography}
%
\end{document}